{"task_id": "HumanEval/0", "completion": "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if any two numbers in the list are closer to each other than the given threshold.\"\"\"\n    numbers.sort()\n    \n    for i in range(len(numbers) - 1):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    \n    return False\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n", "entry_point": "has_close_elements"}
{"task_id": "HumanEval/1", "completion": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"Input is a string containing multiple groups of nested parentheses.\n    Returns a list of each balanced group as individual strings.\"\"\"\n    result = []\n    \n    # Remove all spaces and process the string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize stack to track opening parentheses\n    stack = []\n    \n    for char in paren_string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                continue  # Skip closing unbalanced parentheses\n            \n            result.append(''.join(stack))\n            stack.pop()  # Pop when closing\n        \n        else:\n            continue\n    \n    return result\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n", "entry_point": "separate_paren_groups"}
{"task_id": "HumanEval/2", "completion": "def truncate_number(number: float) -> float:\n    \"\"\"Given a positive floating point number, it can be decomposed into an integer part and a decimal part (always smaller than 1).\n\n    Returns the decimal part of the number.\n\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n    return number - int(number)\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n", "entry_point": "truncate_number"}
{"task_id": "HumanEval/3", "completion": "from typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n    balance = 0\n    for op in operations:\n        if op < 0:\n            return True\n        balance += op\n    return False\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n", "entry_point": "below_zero"}
{"task_id": "HumanEval/4", "completion": "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"Calculate Mean Absolute Deviation (MAD) for a list of numbers.\n\n    Args:\n        numbers: A list of floats representing a dataset.\n\n    Returns:\n        float: The Mean Absolute Deviation.\n    \"\"\"\n    # Calculate the mean of the dataset\n    mean = sum(numbers) / len(numbers)\n    \n    # Compute absolute differences and average them\n    mad = sum(abs(x - mean) for x in numbers) / len(numbers)\n    \n    return mad\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6\n\n", "entry_point": "mean_absolute_deviation"}
{"task_id": "HumanEval/5", "completion": "from typing import List\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\"\n    Insert a number 'delimeter' between every two consecutive elements of input list `numbers`.\n    \n    Parameters:\n        numbers (List[int]): The list to be processed.\n        delimeter (int): The value to insert between each pair of elements.\n\n    Returns:\n        List[int]: A new list with 'delimeter' inserted between each pair.\n    \n    Examples:\n        >>> intersperse([], 4)\n        []\n        \n        >>> intersperse([1, 2, 3], 4)\n        [1, 4, 2, 4, 3]\n    \"\"\"\n    result = []\n    \n    for i in range(len(numbers)):\n        if i == len(numbers) - 1:\n            result.append(delimiter)\n            continue\n        \n        result.append(numbers[i])\n        result.append(delimiter)\n    \n    return result\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n", "entry_point": "intersperse"}
{"task_id": "HumanEval/6", "completion": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"\n    Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    \n    Example:\n        Input: '(()()) ((())) () ((())()())'\n        Output: [2, 3, 1, 3]\n    \n    Parameters:\n        paren_string (str): A string with groups separated by spaces that represent nested parentheses\n    \n    Returns:\n        List[int]: The list containing the deepest nesting levels for each group\n    \"\"\"\n    # Initialize an empty stack to keep track of current depth\n    stack = []\n    \n    # Split the input string into groups based on spaces\n    groups = paren_string.split()\n    \n    result = []\n    \n    for group in groups:\n        # Count current depth using a stack-based approach\n        current_depth = 0\n        \n        if len(group) > 0:\n            stack.append(current_depth)\n        \n            # Increment depth when encountering '(' or ')' characters in this group\n            if '(' in group:\n                current_depth += 1\n            \n            elif ')':\n                if len(stack) > 0 and stack[-1] == current_depth + 1:\n                    result.append(current_depth)\n                    stack.pop()\n                else:\n                    result.append(-1)\n        \n        else:\n            result.append(-1)\n    \n     return result\n\n# Test case example usage (provided in problem description):\n# parse_nested_parens('(()()) ((())) () ((())()())')\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n", "entry_point": "parse_nested_parens"}
{"task_id": "HumanEval/7", "completion": "from typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\"\n    Filter an input list of strings only for those that contain the given substring.\n    \n    Parameters:\n        strings (List[str]): The list of strings to filter.\n        substring (str): The substring to look for in each string.\n    \n    Returns:\n        List[str]: A new list containing only the strings that contain the specified substring.\n    \"\"\"\n    result = [s for s in strings if substring in s]\n    return result\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n", "entry_point": "filter_by_substring"}
{"task_id": "HumanEval/8", "completion": "from typing import List, Tuple\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    \n    - Empty sum should be equal to 0 and empty product should be equal to 1.\n    \n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n    \n    if not numbers:\n        return (0, 1)\n\n    total_sum = sum(numbers)\n    total_product = numbers[0] * numbers[1] if len(numbers) >= 2 else numbers[0]\n\n    for i in range(2, len(numbers)):\n        total_product *= numbers[i]\n\n        # Return early if possible to save computation\n        if total_product == i:\n            break\n\n    return (total_sum + i - number_index - i + number_index + i - number_index,\n            total_product)\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n", "entry_point": "sum_product"}
{"task_id": "HumanEval/9", "completion": "from typing import List, Tuple\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \n    Args:\n        numbers: A list of integers.\n    \n    Returns:\n        A list of integers where each element is the maximum value seen so far up to that index.\n    \"\"\"\n    result = []\n    \n    for num in numbers:\n        max_so_far = max(result or [num])  # Use default if result is empty\n        \n        result.append(max_so_far)\n        \n    return result\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n", "entry_point": "rolling_max"}
{"task_id": "HumanEval/10", "completion": "def make_palindrome(string: str) -> str:\n    \"\"\"\n    Find the shortest palindrome that begins with a supplied string.\n    \n    Algorithm idea:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \n    Example:\n        make_palindrome('cat') \u2192 'catac'\n        make_palindrome('cata') \u2192 'catac'\n    \n    Args:\n        string: The input string to process\n    \n    Returns:\n        The shortest possible palindrome beginning with `string`.\n        \n    \"\"\"\n    if not isinstance(string, str):\n        raise TypeError(\"Input must be a string\")\n    \n    # Edge case: empty input\n    if not string:\n        return \"\"\n    \n    # Check for empty or non-palindromic strings (if possible)\n    \n     # Step 1: Find longest palindromic suffix starting from index 0\n     max_suffix_length = 0\n    \n     for i in range(len(string) - 1, -1, -1):\n         if is_palindrome(string[i:]) == True and i + max_suffix_length > 0 and len(string) > max_suffix_length + i + 1:\n             max_suffix_length = i\n        \n     # Step 2: Construct result by combining parts\n     result = []\n     \n     # Add original part before suffix (up to length `max_suffix_length`)\n     result += list(reversed(result[:max_suffix_length]))\n     \n     # Add prefix part (from start up to `i`)\n     result += list(reversed(result[:i]))\n     \n     return ''.join(result)\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n", "entry_point": "make_palindrome"}
{"task_id": "HumanEval/11", "completion": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\"Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\"\"\"\n    xor_result = []\n    for i in range(len(a)):\n        xor_result.append(str(int(a[i]) ^ int(b[i])))\n    \n    return ''.join(xor_result)\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n", "entry_point": "string_xor"}
{"task_id": "HumanEval/12", "completion": "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\"Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    \n    Args:\n        strings: A list of strings.\n\n    Returns:\n        Optional[str]: The longest string or None if empty.\n    \n    Examples:\n        >>> longest([])\n        None\n    \n        >>> longest(['a', 'b', 'c'])\n        'a'\n    \n        >>> longest(['a', 'bb', 'ccc'])\n        'ccc'\n    \"\"\"\n    if not strings:\n        return None\n    \n    max_len = -1\n    result = \"\"\n    \n    for s in strings:\n        if len(s) > max_len or (len(s) == max_len and s < result):\n            max_len = len(s)\n            result = s\n            \n    return result\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n", "entry_point": "longest"}
{"task_id": "HumanEval/13", "completion": "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"Return the greatest common divisor of two integers a and b.\"\"\"\n    while b != 0:\n        a, b = b, a % b\n    return a\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n", "entry_point": "greatest_common_divisor"}
{"task_id": "HumanEval/14", "completion": "from typing import List\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\"Return list of all prefixes from shortest to longest of the input string.\"\"\"\n    return [s[:i] for i in range(1, len(string) + 1)]\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n", "entry_point": "all_prefixes"}
{"task_id": "HumanEval/15", "completion": "def string_sequence(n: int) -> str:\n    \"\"\"Return a space-delimited string of numbers from 0 to n inclusive.\"\"\"\n    return \" \".join(str(i) for i in range(n + 1))\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n", "entry_point": "string_sequence"}
{"task_id": "HumanEval/16", "completion": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Count the number of distinct characters in a string, case-insensitively.\"\"\"\n    return len(set(string.lower()))\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n", "entry_point": "count_distinct_characters"}
{"task_id": "HumanEval/17", "completion": "from typing import List\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\"Input is a string representing musical notes in special ASCII format.\n    Output is a list of integers corresponding to how many beats each note lasts.\n\n    Args:\n        music_string: A string with musical notes in the format 'o', 'o|', or '.|'.\n\n    Returns:\n        A list containing the number of beats for each note.\n    \"\"\"\n    result = []\n    \n    # Split by spaces (the separators)\n    parts = music_string.split()\n    \n    for part in parts:\n        if part == 'o':\n            result.append(4)\n        elif part == 'o|':\n            result.append(2)\n        elif part == '.|':\n            result.append(1)\n    \n    return result\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n", "entry_point": "parse_music"}
{"task_id": "HumanEval/18", "completion": "def how_many_times(string: str, substring: str) -> int:\n    \"\"\"\n    Find how many times a given substring can be found in the original string.\n    Count overlaping cases.\n\n    Args:\n        string (str): The original string to search within.\n        substring (str): The substring to count.\n\n    Returns:\n        int: The number of occurrences of the substring, including overlaps.\n    \"\"\"\n    \n    # Initialize result with 0\n    count = 0\n    \n    # If the input is empty or the same as itself, return 0\n    if not string or not substring:\n        return 0\n    \n     # Use two pointers approach for efficiency and overlapping handling\n     i = 0\n     n = len(string)\n     m = len(substring)\n    \n     while i < n - m + 1:\n         j = i + m - 1\n        \n         if string[j] == substring[0]:\n             count += 1\n            \n             # Move both pointers forward if there are more matches\n             while j < n and string[j] == substring[0]:\n                 j += 1\n            \n             i = j\n        \n         else:\n             i += 1\n    \n     return count\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n", "entry_point": "how_many_times"}
{"task_id": "HumanEval/19", "completion": "from typing import List\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\"\n    Sorts a string of numbers from 'zero' to 'nine' in ascending order.\n    \n    Args:\n        numbers: A space-delimited string of valid numbers from 'zero' to 'nine'.\n        \n    Returns:\n        A string with the numbers sorted in ascending order.\n        \n    Example:\n        >>> sort_numbers('three one five')\n        'one three five'\n    \"\"\"\n    # Split the input into individual strings\n    parts = numbers.split()\n    \n    # Sort them lexicographically (ascending)\n    sorted_parts = sorted(parts)\n    \n    return \" \".join(sorted_parts)\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n", "entry_point": "sort_numbers"}
{"task_id": "HumanEval/20", "completion": "from typing import List, Tuple\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each other and return them in order (smaller number, larger number).\"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The input list must have at least two elements.\")\n    \n    # Find the two closest elements\n    n = len(numbers)\n    if n == 2:\n        return numbers[0], numbers[1]\n    \n    # Sort the list to easily find the closest pair\n    sorted_numbers = sorted(numbers)\n    \n    # Iterate through possible pairs to find the closest ones\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            current_pair = (sorted_numbers[i], sorted_numbers[j])\n            if abs(current_pair[0] - current_pair[1]) < abs(sorted_numbers[i] - sorted_numbers[j]):\n                smallest = current_pair[0]\n                largest = current_pair[1]\n                break\n    \n    return smallest, largest\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n", "entry_point": "find_closest_elements"}
{"task_id": "HumanEval/21", "completion": "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    \n    Args:\n        numbers: A list of floats\n        \n    Returns:\n        A new list with each element scaled to be between 0 and 1, where smallest becomes 0 and largest becomes 1.\n    \n    Example:\n        >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n        [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    \n    # If there is only one number (should not be possible as per problem statement)\n    if len(numbers) == len(set(numbers)):\n        return []\n    \n    min_val = min(numbers)\n    max_val = max(numbers)\n    \n    scaled = [(min_val - min_val * i) / (max_val - min_val) for i in range(len(numbers))]\n    \n    return scaled\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n", "entry_point": "rescale_to_unit"}
{"task_id": "HumanEval/22", "completion": "from typing import List, Any\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\"\n    Filter given list of any python values only for integers.\n    \n    Parameters:\n        values: A list containing any type of Python value.\n    \n    Returns:\n        A list containing only the integers from the input.\n        \n    Examples:\n        >>> filter_integers(['a', 3.14, 5])\n        [5]\n        >>> filter_integers([1, 2, 3, 'abc', {}, []])\n        [1, 2, 3]\n    \"\"\"\n    filtered = []\n    for val in values:\n        if isinstance(val, int):\n            filtered.append(val)\n    return filtered\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n", "entry_point": "filter_integers"}
{"task_id": "HumanEval/23", "completion": "def strlen(string: str) -> int:\n    \"\"\"Return the length of a given string.\"\"\"\n    return len(string)\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n", "entry_point": "strlen"}
{"task_id": "HumanEval/24", "completion": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number `n`, find the largest number that divides `n` evenly, smaller than `n`.\"\"\"\n    return n - 1\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n", "entry_point": "largest_divisor"}
{"task_id": "HumanEval/25", "completion": "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    \"\"\"Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    \n    Args:\n        n: The integer to factorize\n        \n    Returns:\n        A list containing prime factors, each repeated as many times as they appear.\n        \n    Examples:\n        >>> factorize(8)\n        [2, 2, 2]\n        >>> factorize(25)\n        [5, 5]\n        >>> factorize(70)\n        [2, 5, 7]\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"Input must be a positive integer\")\n    \n    result = []\n    \n    # Check for divisibility by all primes up to sqrt(n)\n    i = 2\n    while i * i <= n:\n        count = 0\n        while n % i == 0:\n            count += 1\n            n //= i\n        \n        result.append(i * count) if count > 0 else continue\n    \n     # If remaining number is greater than one (n is still >1), add it as a prime\n     if n > 1 and not result[-1] == int(result[-1]):\n         result.append(n)\n\n     return result\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n", "entry_point": "factorize"}
{"task_id": "HumanEval/26", "completion": "from typing import List\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    Args:\n        numbers: A list of integers.\n\n    Returns:\n        A new list containing only unique elements (with duplicates removed).\n    \"\"\"\n    return list(set(numbers))\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n", "entry_point": "remove_duplicates"}
{"task_id": "HumanEval/27", "completion": "def flip_case(string: str) -> str:\n    \"\"\"For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\"\"\"\n    return ''.join([c.swapcase() if c.islower() else c for c in string])\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n", "entry_point": "flip_case"}
{"task_id": "HumanEval/28", "completion": "from typing import List\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\"Concatenate list of strings into a single string.\"\"\"\n    return ''.join(strings)\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n", "entry_point": "concatenate"}
{"task_id": "HumanEval/29", "completion": "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\"Filter an input list of strings only for those that start with the given prefix.\"\"\"\n    return [s for s in strings if s.startswith(prefix)]\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n", "entry_point": "filter_by_prefix"}
{"task_id": "HumanEval/30", "completion": "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\"\"\"\n    return [num for num in l if num > 0]\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n", "entry_point": "get_positive"}
{"task_id": "HumanEval/31", "completion": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    \n    Args:\n        n (int): The number to check for primality.\n        \n    Returns:\n        bool: True if n is prime, False otherwise.\n        \n    Examples:\n        >>> is_prime(6)\n        False\n        >>> is_prime(101)\n        True\n        >>> is_prime(11)\n        True\n        >>> is_prime(13441)\n        True\n        >>> is_prime(61)\n        True\n        >>> is_prime(4)\n            False\n            False\n    \n    \"\"\"\n    # Handle edge cases (n < 2 or even after checking divisibility up to sqrt(n))\n    if n <= 1:\n         return False\n    \n    # Check for divisibility up to sqrt(n) + 1 (to avoid redundant checks)\n    \n    for i in range(2, int(n**0.5) + 2):\n         if n % i == 0:\n             return False\n        \n     return True\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n", "entry_point": "is_prime"}
{"task_id": "HumanEval/32", "completion": "\n\nHere is a Python function that implements the described functionality:\n\n```python\nimport math\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    returns xs[0] + xs[1] * x + xs[1] * x^2 + ... + xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\ndef find_zero(xs: list):\n    \"\"\"\n    Find the zero of a polynomial with coefficients `xs`.\n\n     - Returns only the **zero point**, even if there are multiple.\n     - Returns only if there is at least one zero.\n     - Assumes `xs` has even number of coefficients and contains a non-zero coefficient.\n\n     Example:\n        >>> round(find_zero([1, 2]), 2)\n        -0.5 (f(x) = 1 + 2x)\n        >>> round(find_zero([-6, 11, -6, 1]), 2)\n        1.0 (x = [3])\n    \"\"\"\n    \n    # Check if all elements are zero or not\n    all_zeros = True\n    for coeff in xs:\n        if coeff != 0:\n            all_zeros = False\n    \n    # If no non-zero coefficient found -> return None or raise error\n    if not all_zeros:\n        raise ValueError(\"No non-zero coefficient found in input list\")\n\n    \n# Example usage:\nprint(round(find_zero([1, 2]), 2))   # Output: -0.5\nprint(round(find_zero([-6, 11, -6, 4], True)))   # Output: None (if passed as boolean)", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n", "entry_point": "find_zero"}
{"task_id": "HumanEval/33", "completion": "def sort_third(l: list):\n    \"\"\"\n    Sorts the list l such that elements at indices not divisible by 3 remain unchanged,\n    while elements at indices divisible by 3 are sorted in ascending order.\n    \n    Args:\n        l: A list of integers.\n    \n    Returns:\n        A new list with elements sorted as described.\n        \n    Examples:\n        >>> sort_third([1, 2, 3])\n        [1, 2, 3]\n        \n        >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n        [2, 6, 3, 4, 8, 9]\n        \n    \"\"\"\n    result = []\n    \n    for index in range(len(l)):\n        if index % three == not (index % three == -1):\n            result.append(l[index])\n            \n            # If index is divisible by three and we want to keep it as is,\n            # append it to the result\n            if index % three == -1:\n                result.append(l[index])\n                \n                # If we want to keep it sorted in place,\n                # then append a copy of the original element\n                if (index + one) % two != (index + one) % two:\n                    result.append(sorted_values[l[index]])\n                    \n                    # Then add this value back into the list\n                    result.insert(index + one)\n            \n            else:\n                pass\n                \n         return result\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n", "entry_point": "sort_third"}
{"task_id": "HumanEval/34", "completion": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list.\n    \n    Args:\n        l: A list of integers.\n\n    Returns:\n        A new list containing only the unique elements, sorted in ascending order.\n    \n    Example:\n        >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n        [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n", "entry_point": "unique"}
{"task_id": "HumanEval/35", "completion": "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    \n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1])\n    123\n    \"\"\"\n    return max(l)\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n", "entry_point": "max_element"}
{"task_id": "HumanEval/36", "completion": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(1, n + 1):\n        if i % 13 == 0 or i % 11 == 0:\n            count += str(i).count('7')\n    return count\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n", "entry_point": "fizz_buzz"}
{"task_id": "HumanEval/37", "completion": "def sort_even(l: list):\n    \"\"\"\n    Sorts a list by swapping even indices with sorted values.\n    \n    Parameters:\n        l: A list of integers\n    \n    Returns:\n        A new list where even indices (0-based) have their elements sorted.\n    \n    Example:\n        >>> sort_even([1, 2, 3])\n        [1, 2, 3]\n        \n        >>> sort_even([5, 6, 3, 4])\n        [3, 6, 5, 4]\n    \"\"\"\n    # Create a copy of the original list to avoid modifying it in-place\n    l_copy = l.copy()\n    \n    # Iterate over the elements and swap them if they are at an odd index (0-based)\n    for i in range(1):\n        if i % 2 == True:\n            # If index is even (i.e., not at start), we want to keep it as-is,\n            # but if it's at an odd position and has a value,\n            # we will replace with its sorted version.\n            value = l_copy[i]\n            sorted_value = value\n            for j in range(i + i + len(value)):\n                if j < len(value):\n                    sorted_value += str(sorted_value[j])\n                else:\n                    break\n            l_copy[i] = int(sorted_value)\n    \n    return l_copy\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n", "entry_point": "sort_even"}
{"task_id": "HumanEval/38", "completion": "def decode_cyclic(s: str):\n    \"\"\"\n    Decodes a cyclically encoded string back to its original form.\n    \"\"\"\n    # Split the encoded string into groups of 3 characters, cycling if necessary.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    \n    # Reverse each group and join them back together.\n    return \"\".join(group[::-1] for group in groups)\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n", "entry_point": "decode_cyclic"}
{"task_id": "HumanEval/39", "completion": "def prime_fib(n: int):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    fib = [0, 1]\n    index = 2\n    while len(fib) < n:\n        next_val = fib[index - 1] + fib[index]\n        if is_prime(next_val):\n            fib.append(next_val)\n            index += 1\n\n    return fib[n - 1]\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n", "entry_point": "prime_fib"}
{"task_id": "HumanEval/40", "completion": "def triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero takes a list of integers as an input.\n    it returns True if there are three distinct elements in the list that\n    sum to zero, and False otherwise.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n    \n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n", "entry_point": "triples_sum_to_zero"}
{"task_id": "HumanEval/41", "completion": "def car_race_collision(n: int) -> int:\n    \"\"\"\n    Calculates the number of collisions between two sets of n cars driving left to right and right to left.\n\n    Args:\n        n: Number of cars in each set.\n\n    Returns:\n        The number of collisions.\n    \"\"\"\n    return n * (n - 1) // 2\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n", "entry_point": "car_race_collision"}
{"task_id": "HumanEval/42", "completion": "def incr_list(l: list):\n    \"\"\"Return a new list where each element is increased by 1.\"\"\"\n    return [x + 1 for x in l]\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n", "entry_point": "incr_list"}
{"task_id": "HumanEval/43", "completion": "def pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero takes a list of integers as an input.\n    it returns True if there are two distinct elements in the list that\n    sum to zero, and False otherwise.\n\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([])\n        # empty list is not considered as per problem statement (returns False)\n    \n        \"\"\"\n    \n     # Create a frequency dictionary to count occurrences of each number in the list\n    \n     freq = {}\n     for num in l:\n         freq[num] = freq.get(num) + l.count(num)\n    \n     # Check if there are at least two numbers whose sum is zero\n    \n     return any(freq[key] > l.count(key) for key in freq)\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n", "entry_point": "pairs_sum_to_zero"}
{"task_id": "HumanEval/44", "completion": "def change_base(x: int, base: int):\n    \"\"\"\n    Change numerical base of input number x to base.\n    return string representation after the conversion.\n    \n    Parameters:\n        x: integer value of the original number\n        base: integer representing the target base (must be less than 10)\n    \n    Returns:\n        str: string representation of x in the new base\n    \"\"\"\n    if x < 0 or x > (base - 1):\n        raise ValueError(\"Negative numbers are not allowed in this function\")\n    \n    digits = []\n    \n    # Convert from decimal to another format by dividing by 'base'\n    while x > 0:\n        remainder = x % base\n        digits.append(remainder)\n        \n        # Update 'x' with quotient after division by 'base'\n        x //= base\n    \n    # Reverse and convert back to integer, then back to string\n    result = ''\n    \n    for digit in reversed(digits):\n        result += str(digit)\n        \n    return result if result else \"0\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n", "entry_point": "change_base"}
{"task_id": "HumanEval/45", "completion": "def triangle_area(a, h):\n    \"\"\"Given length of a side and high return area for a triangle.\n    \n    Args:\n        a (float): Length of one side of the triangle.\n        h (float): Height corresponding to that side.\n        \n    Returns:\n        float: Area of the triangle.\n        \n    Example:\n        >>> triangle_area(5, 3)\n        7.5\n    \"\"\"\n    return (a * h) / 2\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n", "entry_point": "triangle_area"}
{"task_id": "HumanEval/46", "completion": "def fib4(n: int):\n    if n == 0:\n        return 0\n    elif n == 1 or n == 2:\n        return 0\n    else:\n        a, b, c = 0, 0, 2\n        for _ in range(3, n + 1):\n            d = a + b + c + d_prev_prev\n            # Update variables in order to avoid recomputation (d is updated)\n            # So we need to track previous values properly.\n            # To avoid recomputing from scratch each time,\n            # we can keep track of three previous values and update them accordingly.\n        \n        return c if n == len(a) else d\n\n# Example usage:\nprint(fib4(5))   # Output: 4\nprint(fib4(6))   # Output: 8\nprint(fib4(7))   # Output: 14\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n", "entry_point": "fib4"}
{"task_id": "HumanEval/47", "completion": "def median(l: list):\n    l.sort()\n    n = len(l)\n    if n % 2 == 1:\n        return l[n // 2]\n    else:\n        return (l[n // 2 - 1] + l[n // 2]) / 2.0\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n", "entry_point": "median"}
{"task_id": "HumanEval/48", "completion": "def is_palindrome(text: str) -> bool:\n    \"\"\"Checks if given string is a palindrome.\"\"\"\n    return text == text[::-1]\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n", "entry_point": "is_palindrome"}
{"task_id": "HumanEval/49", "completion": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    if n == 0:\n        return 1 if p > 1 else 0\n    result = pow(2, n, p)\n    return result\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n", "entry_point": "modp"}
{"task_id": "HumanEval/50", "completion": "def encode_shift(s: str) -> str:\n    \"\"\"\n    Returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str) -> str:\n    \"\"\"\n    Takes as input a string encoded with encode_shift, returns decoded string.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n", "entry_point": "decode_shift"}
{"task_id": "HumanEval/51", "completion": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \n    Args:\n        text (str): The input string to process.\n    \n    Returns:\n        str: A new string with all vowels removed.\n        \n    Examples:\n        >>> remove_vowels('')\n        ''\n        >>> remove_vowels(\"abcdef\\nghijklm\")\n        'bcdf\\nghjklm'\n        >>> remove_vowels('abcdef')\n        'bcdf'\n        >>> remove_vowels('aaaaa')\n        ''\n        >>> remove_vowels('aaBAA')\n        'B'\n        >>> remove_vowels('zbcd')\n         'zbcd'\n    \"\"\"\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    \n    return ''.join([char for char in text if char not in vowels])\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n", "entry_point": "remove_vowels"}
{"task_id": "HumanEval/52", "completion": "def below_threshold(l: list, t: int) -> bool:\n    \"\"\"Return True if all numbers in the list l are below threshold t.\"\"\"\n    return all(num < t for num in l)\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n", "entry_point": "below_threshold"}
{"task_id": "HumanEval/53", "completion": "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y.\"\"\"\n    return x + y\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n", "entry_point": "add"}
{"task_id": "HumanEval/54", "completion": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \n    Args:\n        s0 (str): First word to compare.\n        s1 (str): Second word to compare.\n        \n    Returns:\n        bool: True if both words have the same characters, False otherwise.\n    \"\"\"\n    return sorted(set(s0)) == sorted(set(s1))\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n", "entry_point": "same_chars"}
{"task_id": "HumanEval/55", "completion": "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n", "entry_point": "fib"}
{"task_id": "HumanEval/56", "completion": "def correct_bracketing(brackets: str) -> bool:\n    left = right = 0\n    for char in brackets:\n        if char == '<':\n            left += 1\n        else:\n            right += 1\n        if left > right or (left == right and char != '>'):\n            return False\n    return True\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n", "entry_point": "correct_bracketing"}
{"task_id": "HumanEval/57", "completion": "def monotonic(l: list):\n    \"\"\"\n    Return True if the list elements are monotonically increasing or decreasing.\n    \n    Args:\n        l: A list of integers.\n\n    Returns:\n        True if the elements are non-decreasing (or non-increasing), False otherwise.\n    \n    Examples:\n        >>> monotonic([1, 2, 4, 20])\n        True\n        >>> monotonic([1, 20, 4, 10])\n        False\n        >>> monotonic([4, 1, 0, -10])\n        True\n    \"\"\"\n    # Check for both increasing and decreasing cases\n    return all(l[i] <= l[i + 1] for i in range(len(l) - 1)) or all(l[i] >= l[i + 1] for i in range(len(l) - 1))\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n", "entry_point": "monotonic"}
{"task_id": "HumanEval/58", "completion": "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Return a sorted list of unique common elements between two input lists.\n    \n    Args:\n        l1: First list of integers.\n        l2: Second list of integers.\n\n    Returns:\n        A sorted list containing only the unique elements that are present in both lists.\n    \"\"\"\n    return sorted(set(l1) & set(l2))\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n", "entry_point": "common"}
{"task_id": "HumanEval/59", "completion": "def largest_prime_factor(n: int):\n    if n == 1:\n        return None  # Edge case, but since n is not a prime and >1, this should not occur\n    \n    # Start from the smallest possible factor\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            # If it's divisible by `i`, then it's a prime factor\n            largest_prime_factor = max(largest_prime_factor, i)\n            # Remove all factors of `i` from `n`\n            while n % i == 0:\n                n //= i\n    \n        # Move to next possible factor after dividing by its square root to avoid redundant checks\n        if (i * i) != (n - 1):\n            break\n    \n    return largest_prime_factor or None\n\n# Test cases\nprint(largest_prime_factor(13195))   # Output: 29\nprint(largest_prime_factor(2048))   # Output: 2\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n", "entry_point": "largest_prime_factor"}
{"task_id": "HumanEval/60", "completion": "def sum_to_n(n: int):\n    \"\"\"Sum numbers from 1 to n.\"\"\"\n    return n * (n + 1) // 2\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n", "entry_point": "sum_to_n"}
{"task_id": "HumanEval/61", "completion": "def correct_bracketing(brackets: str) -> bool:\n    balance = 0  # Number of open brackets remaining\n    \n    for char in brackets:\n        if char == '(':\n            balance += 1\n        else:  # char == ')'\n            balance -= 1\n            \n        # If at any point, the number of closing brackets exceeds the opening ones, return False\n        if balance < 0:\n            return False\n    \n    return True\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n", "entry_point": "correct_bracketing"}
{"task_id": "HumanEval/62", "completion": "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ...\n    \n    Return derivative of this polynomial in the same form.\n    \n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    \n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n    return [xs[i+1] for i in range(len(xs)) - 1]\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n", "entry_point": "derivative"}
{"task_id": "HumanEval/63", "completion": "\n\nHere's a Python function that efficiently computes the `n-th` element of the `fibfib` number sequence, which follows the recurrence:\n\n- `fibfib(0) = 0`\n- `fibfib(1) = 0`\n- `fibfib(n) = fibfib(n-1) + fibfib(n-2) + fibbin(n-3)` for n \u2265 3.\n\n```python\ndef fibfibs(n: int):\n    if n < 3:\n        return n\n    a, b, c = 0, 0, 1\n    for _ in range(2, n):\n        new_value = a + b + c\n        a, b, c = b, c, new_value\n    return c if n == 3 else new_value\n\n# Example usage:\nprint(fibfibs(5))   # Output: 4", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n", "entry_point": "fibfib"}
{"task_id": "HumanEval/64", "completion": "def vowels_count(s):\n    \"\"\"Count vowels in a string, including 'y' at the end.\"\"\"\n    return sum(1 for char in s if char.lower() in {'a', 'e', 'i', 'o', 'u'} or char == 'y')\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "vowels_count"}
{"task_id": "HumanEval/65", "completion": "def circular_shift(x, shift):\n    \"\"\"\n    Circular shift the digits of the integer x, shift right by 'shift' and return as a string.\n    If 'shift' > number of digits, return digits reversed.\n\n    Parameters:\n        x (int): The integer to be shifted.\n        shift (int): The number of digits to shift right.\n\n    Returns:\n        str: The shifted number as a string.\n    \"\"\"\n    if not isinstance(x, int) or not isinstance(shift, int):\n        raise ValueError(\"x and shift must be integers\")\n\n    num_digits = len(str(abs(x)))\n    \n    if abs(shift) > num_digits:\n        # Reverse if shifting more than possible\n        return str(int(x))[::-1]\n    \n    # Perform right rotation by 'shift'\n    rotated = str(int(str(abs(x))[:num_digits - shift] + str(abs(x))[num_digits - shift:]))\n\n# Test cases\nprint(circular_shift(12, 1))  # Output: \"21\"\nprint(circular_shift(12, 2))  # Output: \"12\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "circular_shift"}
{"task_id": "HumanEval/66", "completion": "def digitSum(s):\n    \"\"\"\n    Task: Write a function that takes a string as input and returns the sum of the upper characters only' ASCII codes.\n\n    Examples:\n        digitSum(\"\") => 0\n        digitSum(\"abAB\") => 131\n        digitSum(\"abcCd\") => 67\n        digitSum(\"helloE\") => 69\n        digitSum(\"woArBld\") => 131\n        digitSum(\"aAaaaXa\") => 153\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    int: The sum of the ASCII values of all uppercase characters in 's'.\n    \"\"\"\n    return sum(ord(c) for c in s if c.isupper())\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n", "entry_point": "digitSum"}
{"task_id": "HumanEval/67", "completion": "def fruit_distribution(s, n):\n    apples, oranges = map(int, s.split())\n    mango = n - apples - oranges\n    return mango\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n", "entry_point": "fruit_distribution"}
{"task_id": "HumanEval/68", "completion": "def pluck(arr):\n    if not arr:\n        return []\n    \n    # Create a list of tuples with (value, index) for each node\n    nodes = [(node.value, idx) for idx, node in enumerate(arr)]\n    \n    # Filter nodes to find those with even values\n    even_nodes = [node for node in nodes if node[0] % 2 == 0]\n    \n    # If no even values found or array is empty, return empty list\n    if not even_nodes:\n        return []\n    \n    # Find the one with smallest value and smallest index among them\n    result = min(even_nodes, key=lambda x: (x[0], x[1]))\n    \n    return [result[0], result[1]]\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n", "entry_point": "pluck"}
{"task_id": "HumanEval/69", "completion": "def search(lst):\n    \"\"\"\n    Given a list of positive integers, return the greatest integer that is greater than zero and has a frequency greater than or equal to its value.\n    If no such integer exists, return -1.\n\n    Args:\n        lst (list): List of positive integers.\n\n    Returns:\n        int: The greatest integer meeting the condition, or -1 if not found.\n    \"\"\"\n    from collections import Counter\n\n    count = Counter(lst)\n    \n    for num in count:\n        if count[num] >= num and num > 0:\n            return num\n    \n    return -1\n", "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n", "entry_point": "search"}
{"task_id": "HumanEval/70", "completion": "def strange_sort_list(lst):\n    \"\"\"\n    Given a list of integers, return a list in a strange order.\n    \n    Strange sorting works by:\n    - Starting with the minimum value,\n    - Then the maximum of the remaining integers,\n    - Then repeat this process until only one element remains.\n    \n    Examples:\n        strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n        strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n        strange_sort_list([]) == []\n    \n    Parameters:\n        lst (list): List of integers to sort\n    \n    Returns:\n        list: Sorted list according to strange rules\n    \"\"\"\n    \n    if not lst:\n        return []\n    \n# Sort the list using a recursive approach\nsorted_lst = sorted(lst)\nreturn sorted_lst[0] + [sorted_lst[i] for i in range(1)] + sorted_lst[-1:]\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "strange_sort_list"}
{"task_id": "HumanEval/71", "completion": "def triangle_area(a, b, c):\n    \"\"\"\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n    Otherwise return -1\n    \n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    \n    Example:\n        triangle_area(3, 4, 5) == 6.00\n        triangle_area(1, 2, 10) == -1\n    \n    Args:\n        a (float): Length of first side\n        b (float): Length of second side\n        c (float): Length of third side\n        \n    Returns:\n        float: Area rounded to two decimal places or -1 if invalid\n        \n    Raises:\n        ValueError: If invalid input for length in case where sum < other side)\n         and returns -1 accordingly.\n     \"\"\"\n    \n    # Check if it's a valid triangle by checking all conditions\n    if not all(0 < x <= y + z for x, y, z in zip(a, b, c)):\n        return -1\n    \n     # Calculate area using Heron's formula: sqrt(s*(s-a)*(s-b)*(s-c))\n     s = (a + b + c) / 2  \n     area = s * (s - a) * (s - b) * (s - c)\n     \n     # Return result rounded to two decimal places or \"-1\" as specified\n     return round(area * 100 / 100.0) if abs(area) > 8e-4 else \"-1\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n", "entry_point": "triangle_area"}
{"task_id": "HumanEval/72", "completion": "def will_it_fly(q, w):\n    \"\"\"\n    Returns True if the object q will fly, given that it is balanced (a palindromic list) and the sum of its elements is less than or equal to the maximum possible weight w.\n    \n    Args:\n        q (list): The list representing the object.\n        w (int): The maximum possible weight for flying.\n        \n    Returns:\n        bool: True if both conditions are satisfied; False otherwise.\n    \"\"\"\n    # Check if q is a palindrome\n    if q == q[::-1]:\n        # Check sum of elements <= w\n        total = sum(q)\n        return total <= w\n    else:\n        return False\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n", "entry_point": "will_it_fly"}
{"task_id": "HumanEval/73", "completion": "def smallest_change(arr):\n    \"\"\"\n    Given an array arr of integers, find the minimum number of elements that need to be changed to make the array palindromic. A palindromic array is an array that is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n    For example:\n        smallest_change([1, 2, 3, 5, 4, 7, 9, 6]) == 4\n        smallest_change([1, 2, 3, 4, 3, 2]) == -1 (error)\n        smallest_change([1000000]) == -1 (empty list?)\n\n    \"\"\"\n    n = len(arr)\n    \n    # Create a mirror of the first half of the list excluding middle part\n    left = arr[::2]\n    right = arr[n//2 + :n//2 +1]\n    \n    # Count mismatches between left and right parts\n    count = sum(1 for x in left if x != right[::])\n    \n    return count if n % len(left) == len(right) else -1\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n", "entry_point": "smallest_change"}
{"task_id": "HumanEval/74", "completion": "def total_match(lst1, lst2):\n    \"\"\"\n    Returns a list containing all strings from `lst1` that have fewer characters than those in `lst2`.\n\n    If both lists have the same number of characters, returns the first list.\n\n    Args:\n        lst1 (list): List of strings.\n        lst2 (list): List of strings.\n\n    Returns:\n        list: A new list containing only strings from `lst1` with fewer characters than in `lst2`.\n    \"\"\"\n    # Sort both lists by length to easily compare\n    sorted_lst1 = sorted(lst1, key=len)\n    sorted_lst2 = sorted(lst2, key=len)\n\n    # Find indices where each string has less length than another\n    result = []\n    \n    for i in range(len(sorted_lst1)):\n        if len(sorted_lst1[i]) < len(sorted_lst2[i]):\n            result.append(sorted_lst1[i])\n    \n        elif len(sorted_lst1[i]) == len(sorted_lst2[i]):\n            # If lengths are equal, add first element from both lists\n            result.append(sorted_lst1[i])\n    \n        else:\n            # If lengths differ and we're at end of list\n            break\n    \n    return result\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n", "entry_point": "total_match"}
{"task_id": "HumanEval/75", "completion": "def is_multiply_prime(a):\n    \"\"\"Returns True if the number is the product of exactly three prime numbers and False otherwise.\"\"\"\n    if a < 3:\n        return False\n\n    # Check divisibility by small primes\n    for i in range(2, int(a**0.5) + 1):\n        if a % i == 0:\n            return False\n\n    # Now check divisibility by more primes (up to sqrt(a))\n    for i in range(2, int(a**0.5) + 1):\n        if a % i == 0:\n            return False\n\n    # If all are prime and there are exactly three factors, then it's multiply-prime\n    factors = []\n    \n    temp = a\n    while temp > 1:\n        temp //= i\n    \n    return len(factors) == 3 and all(i in factors for i in [2,3,5])\n", "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n", "entry_point": "is_multiply_prime"}
{"task_id": "HumanEval/76", "completion": "def is_simple_power(x, n):\n    \"\"\"Returns True if x is a simple power of n, else False.\"\"\"\n    return int(n ** (1 / n)) == x\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "is_simple_power"}
{"task_id": "HumanEval/77", "completion": "def iscube(a):\n    \"\"\"\n    Check if the input integer is a perfect cube of some integer.\n    \n    Args:\n        a (int): The number to check\n        \n    Returns:\n        bool: True if the number is a perfect cube, False otherwise\n    \n    Examples:\n        iscube(1)  => True\n        iscube(2)  => False\n        iscube(-1) => True\n        iscube(64) => True\n        iscube(0)  => True\n        iscube(180) => False\n    \"\"\"\n    # Check for cubes in the range [a^(1/3), (a+1)^{1/3}]\n    # Since we assume input values are valid, no need to handle edge cases.\n    \n    # We can use binary search here.\n    \n    left = int(a ** (1/3)) + 1  # Start from one more than the cube root\n    \n    while left <= a:\n        right = int((left + left - 2)**(1/3)) + 2\n        \n        if right > left and ((right ** 3 == a or right ** 3 - a == abs(left - right))):\n            return True\n            \n            break\n            \n                return False\n                \n                break\n            \n            break\n    \n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n", "entry_point": "iscube"}
{"task_id": "HumanEval/78", "completion": "def hex_key(num):\n    \"\"\"\n    Counts the number of hexadecimal digits that are prime numbers.\n    \n    Prime numbers in hexadecimal are 2, 3, 5, 7, B (11), D (13).\n    \n    Args:\n        num (str): A string representing a hexadecimal number.\n        \n    Returns:\n        int: The count of prime digits in the input number.\n    \"\"\"\n    # Convert to lowercase for easy comparison with uppercase symbols\n    num_lower = num.lower()\n    \n    # Define set of allowed prime characters in hex\n    primes = {'2', '3', '5', '7', 'B', 'D'}\n    \n    count = 0\n    \n    for char in num_lower:\n        if char in primes:\n            count += 1\n            \n    return count\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n", "entry_point": "hex_key"}
{"task_id": "HumanEval/79", "completion": "def decimal_to_binary(decimal):\n    \"\"\"You will be given a number in decimal form and your task is to convert it to\n    binary format. The function should return a string, with each character representing a binary\n    number. Each character in the string will be '0' or '1'.\n\n    There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    The extra characters are there to help with the format.\n\n    Examples:\n        decimal_to_binary(15)   # returns \"db1111db\"\n        decimal_to_binary(32)   # returns \"db100000db\"\n    \"\"\"\n    \n    if not isinstance(decimal, int):\n        raise ValueError(\"Input must be an integer\")\n\n    \n    result = \"db\" + bin(decimal)[2:] + \"db\"\n    \n    return result\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "decimal_to_binary"}
{"task_id": "HumanEval/80", "completion": "def is_happy(s):\n    \"\"\"You are given a string s.\n    Your task is to check if the string is happy or not.\n    A string is happy if its length is at least 3 and every 3 consecutive letters are distinct.\"\"\"\n    \n    # Check length condition\n    if len(s) < 3:\n        return False\n    \n    # Check all consecutive triplets have distinct characters\n    for i in range(len(s) - 2):\n        chars = set()\n        for j in range(i, i + 3):\n            chars.add(s[j])\n        \n        # If any triplet has duplicate characters, return False\n        if len(chars) != 3:\n            return False\n    \n    return True\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n", "entry_point": "is_happy"}
{"task_id": "HumanEval/81", "completion": "def numerical_letter_grade(grades):\n    \"\"\"\n    Converts a list of GPA values to their corresponding letter grades.\n\n    Parameters:\n        grades (list): A list of float numbers representing GPAs.\n\n    Returns:\n        list: A list of string representations of letter grades.\n    \"\"\"\n    result = []\n    \n    # Define the mapping for GPA to letter grade\n    mapping = {\n        4.0: 'A+',\n        3.7: 'A',\n        3.3: 'A-',\n        3.0: 'B+',\n        2.7: 'B',\n        2.3: 'B-',\n        2.0: 'C+',\n        1.7: 'C',\n        1.3: 'C-',\n        1.0: 'D+',\n         -0.75 or -0.: \"D\",\n         -1.: \"D-\",\n         -2.: \"E\"\n     }\n    \n    for grade in grades:\n       result.append(mapping.get(grade, \"\"))\n        \n   return result\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "numerical_letter_grade"}
{"task_id": "HumanEval/82", "completion": "def prime_length(string):\n    \"\"\"\n    Takes a string and returns True if its length is a prime number or False otherwise.\n    \n    Examples:\n    - prime_length('Hello') == True\n    - prime_length('abcdcba') == True\n    - prime_length('kittens') == True\n    - prime_length('orange') == False\n    \n    Parameters:\n        string (str): The input string to check.\n\n    Returns:\n        bool: True if the length is a prime, False otherwise.\n    \"\"\"\n    \n    # Calculate the length of the string\n    n = len(string)\n    \n    # Check if n is 2, which is the smallest even number greater than 1 (prime)\n     # For numbers less than 2, return False since they are not primes.\n     if n < 2:\n         return False\n    \n     # Check divisibility by all integers from 3 up to sqrt(n), incrementing by 2 for odd numbers,\n     for i in range(3, int(n**0.5) + 1, 2):\n         if n % i == 0:\n             return False\n    \n     return True\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n", "entry_point": "prime_length"}
{"task_id": "HumanEval/83", "completion": "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\n    if n == 0:\n        return 0\n    \n    # The first digit must be '1' (for numbers starting)\n    # The last digit must be '1' (for numbers ending)\n    \n    # For each number to have exactly n digits, it ranges from 10^(n-1) to 10^n - 1\n    \n    # Numbers starting with '1': First digit is fixed as '1', remaining can be any value from 0 to 9\n    count_start = (9 + 2) * (n - 2) if n > 2 else (9 * (n - 2)) + (3 * (n - 2))\n    \n    # Numbers ending with '1': Last digit is fixed as '1', remaining can be any value from ... up to whatever makes it an n-digit number\n    \n    # If there are enough digits left for the middle part, then we can place any valid combination here\n    \n     if len(str(n)) > n:\n         return count_start + ((9 * len(str(n))) // len(str(5)))   else:\n         return count_start\n\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "starts_one_ends"}
{"task_id": "HumanEval/84", "completion": "def solve(N):\n    \"\"\"Given a positive integer N, return the total sum of its digits in binary.\n    \n    Example\n        For N = 1000, the sum of digits will be 1 the output should be \"1\".\n        For N = 150, the sum of digits will be 6 the output should be \"110\".\n        For N = 147, the sum of digits will be 12 the output should be \"1100\".\n    \n    Variables:\n        @N integer\n             Constraints: 0 \u2264 N \u2264 10000.\"\"\"\n    # Convert to binary and take only non-zero digits (since leading zeros are not counted)\n    binary_str = bin(N)[2:] if N > 0 else \"\"\n    \n    # Calculate digit sum in binary (only non-zero)\n    digit_sum = sum(int(bit) for bit in binary_str if bit != '0')\n    \n    return f\"{digit_sum}\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n", "entry_point": "solve"}
{"task_id": "HumanEval/85", "completion": "def add(lst):\n    result = []\n    for index, num in enumerate(lst):\n        if index % 2 == 1 and num % 2 == 0:\n            result.append(num)\n    return sum(result)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n", "entry_point": "add"}
{"task_id": "HumanEval/86", "completion": "def anti_shuffle(s):\n    words = s.split()\n    sorted_words = sorted(words)\n    return ''.join(sorted_words)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "anti_shuffle"}
{"task_id": "HumanEval/87", "completion": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2-dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    \n    Given lst and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    \n    Sort coordinates initially by rows in ascending order.\n    \n    Also sort coordinates of the row by columns in descending order.\n    \n    Examples:\n        get_row([\n            [1,2,3,4,5],\n            [1],\n            [1]\n        ], 1) == [(0.0,), (0.5,), (0.5)]\n        \n        get_row([], 3) == []\n        \n        get_row([[], [1], [1]], 3) == [(2., 2)]\n        \n        get_row([[4], [], []], 4) == [[(4,), []]]\n\"\"\"\n    \n    result = []\n    \n    # Iterate through all elements in the list\n     for i in range(len(lst)):\n         current = lst[i]\n         # Convert to tuples for easy comparison\n         coord = tuple(current)\n         if coord[0] == x:\n             result.append(coord)\n            \n     # Sort by row index first then column index last\n     result.sort(key=lambda coord: (coord[0], -coord[1]))\n     \n     return result\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "get_row"}
{"task_id": "HumanEval/88", "completion": "def sort_array(array):\n    \"\"\"\n    Given an array of non-negative integers, return a copy of the given array after sorting,\n    you will sort the given array in ascending order if the sum of its first and last elements is odd,\n    or sort it in descending order if even.\n\n    Note:\n        * don't change the given array.\n        * use only built-in functions and no external libraries.\n    \"\"\"\n    first = array[0]\n    last = array[-1]\n    \n    sum_first_last = first + last\n    \n    if sum_first_last % 2 == 1:\n        sorted_array = sorted(array)\n        return sorted_array\n    else:\n        return sorted(array)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n", "entry_point": "sort_array"}
{"task_id": "HumanEval/89", "completion": "def encrypt(s):\n    \"\"\"\n    Encrypts a string by rotating the alphabet two places down.\n    \n    Parameters:\n        s (str): The input string to be encrypted.\n    \n    Returns:\n        str: The encrypted string.\n    \"\"\"\n    result = []\n    for char in s:\n        if char.isalpha():\n            # Convert to lowercase for consistent rotation\n            shifted_char = chr((ord(char.lower()) - ord('a') - 2) % 26 + ord('a'))\n            result.append(shifted_char)\n        else:\n            result.append(char)\n    \n    return ''.join(result)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "encrypt"}
{"task_id": "HumanEval/90", "completion": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    Examples:\n        next_smallest([1, 2, 3, 4, 5]) == 2\n        next_smallest([5, 1, 4, 3, 2]) == 2\n        next_smallest([]) == None\n        next_smallest([1, 1]) == None\n    \n    Parameters:\n        lst (list): A list of integers\n    \n    Returns:\n        int or None: The second smallest integer in the list (None if there is none)\n    \"\"\"\n    \n    # Sort the list to find the second smallest number\n    sorted_list = sorted(lst)\n    \n    # Check if there are at least two elements in the sorted list\n    return sorted_list[1] if len(sorted_list) >= 2 else None\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "next_smallest"}
{"task_id": "HumanEval/91", "completion": "def is_bored(S):\n    \"\"\"\n    You'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is a sentence that starts with the word \"I\".\n    Sentences are delimited by '.', '?' or '!'.\n    \n    For example:\n        >>> is_bored(\"Hello world\")\n        0\n        >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n        1\n    \n    Parameters:\n        S: A string containing words separated by spaces.\n    \n    Returns:\n        int: The number of boredoms in the input string.\n    \"\"\"\n    \n    # Split the sentence into tokens (words)\n    tokens = S.split()\n    \n    # Check each token for \"I\" followed by any characters (or empty if it's at the end)\n    count = 0\n    \n    for token in tokens:\n        if token == \"I\":\n            # Check if there's any more content after \"I\"\n            if len(tokens) > 1 and tokens[-1] != '.' and tokens[-1] != '?':\n                count += 1\n                \n                # If there are more than one character after, it's not a full sentence\n                if len(tokens) > 2 and len(tokens[-2:]) > 2:\n                    continue\n                \n                else:\n                    break\n            \n            else:\n                continue\n        \n        else:\n            break\n    \n    return count\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "is_bored"}
{"task_id": "HumanEval/92", "completion": "def any_int(x, y, z):\n    \"\"\"\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n\n    Examples:\n        any_int(5, 2, 7) \u279e True\n        any_int(3, -2, 1) \u279e True\n        any_int(3.6, -2.2, 2) \u279e False\n\n    Args:\n        x: first number (int or float)\n        y: second number (int or float)\n        z: third number (int or float)\n\n    Returns:\n        bool: returns True only if one of the numbers is equal to sum of others and all are integers.\n    \n    Raises:\n        ValueError: if inputs are not integers or floats.\n    \"\"\"\n    \n    # Check for valid input types\n    if not isinstance(x, (int | float)) or \\\n       not isinstance(y, (int | float)) or \\\n       not isinstance(z, (int | float)):\n        \n        raise ValueError(\"All inputs must be integers or floats.\")\n    \n     # Check for equality conditions\n    \n     return (\n         abs(x + y - z) == x + y and \n         abs(y + z - x) == y + z and \n         abs(z + x - y) == z + x\n     )\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n", "entry_point": "any_int"}
{"task_id": "HumanEval/93", "completion": "def encode(message):\n    \"\"\"\n    Encodes a message by swapping case of all letters, replacing vowels with their 2 places ahead letter.\n    \n    Args:\n        message (str): The input string to encode.\n        \n    Returns:\n        str: The encoded string.\n    \"\"\"\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    \n    result = []\n    \n    for char in message:\n        if char.islower():\n            result.append(char.upper())\n        elif char.isupper():\n            result.append(char.lower())\n        else:\n            # Handle non-alphabetic characters (though problem says only letters)\n            pass\n            \n        # Replace vowel with next letter 2 positions ahead\n        if char in vowels:\n            next_char = chr(ord(char) + 2)\n            result.append(next_char)\n    \n    return ''.join(result)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "encode"}
{"task_id": "HumanEval/94", "completion": "def skjkasdkd(lst):\n    sum_digits = 0\n    max_prime = 0\n\n    for num in lst:\n        if is_prime(num):\n            max_prime = num\n            sum_digits += num\n\n    return sum_digits\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n", "entry_point": "skjkasdkd"}
{"task_id": "HumanEval/95", "completion": "\n\nHere's a Python function that checks if all keys in a dictionary are either lowercase or uppercase:\n\n```python\ndef check_dict_case(dict):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    \n    Args:\n        dict: A dictionary with key-value pairs.\n\n    Returns:\n        True if all keys are lowercase or uppercase; else False.\n        \n    Examples:\n        check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) \u2192 True\n        check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) \u2192 False\n        check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) \u2192 False\n        check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) \u2192 False\n        check_dict_case({\"STATE\": \"NC\", \"ZIP\": \"12345\"}) \u2192 True\n    \"\"\"\n    # Check for empty dict (should return false)\n    if not dict:\n        return False\n    \n    # Check for any mixed case (should return false)\n    \n     # Convert each key to lowercase and compare with the first one's case\n    \n     first_key = next(iter(dict.keys()))\n     for key, value in dict.items():\n         key_lower = key.lower()\n         value_lower = value.lower()\n         # If both cases differ, it's invalid (return false)\n         if not (key_lower == first_key.lower() or value_lower == first_key.lower()):\n             break\n    \n     else:\n         return True\n\n# Example usage:\nprint(check_dict_case({\"a\": \"apple\"}))  # Output: True\nprint(check_dict_case({}))                # Output: False", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n", "entry_point": "check_dict_case"}
{"task_id": "HumanEval/96", "completion": "def count_up_to(n):\n    \"\"\"\n    Takes a non-negative integer and returns an array of the first n integers that are prime numbers and less than n.\n    \n    Parameters:\n        n (int): A non-negative integer.\n        \n    Returns:\n        list: An array containing the first n primes less than or equal to n.\n        \n    Examples:\n        count_up_to(5) => [2, 3]\n        count_up_to(11) => [2, 3, 5, 7]\n        count_up_to(0) => []\n        count_up_to(20) => [2, 3, 5, 7, 11, 13, 17, 19]\n        count_up_to(1) => []\n    \"\"\"\n    primes = []\n    \n    # Check if input is valid (n must be \u22650)\n    if not isinstance(n, int):\n        raise ValueError(\"Input must be an integer.\")\n    \n    if n < min(0):\n        return primes\n    \n    # Generate all prime numbers up to 'n'\n    \n    def is_prime(num):\n        if num < -n + max_primes_limit or num > max_primes_limit:\n            return False\n         # Check divisibility up to sqrt(num)\n         for i in range(2 * int(num**0.5), num + len(str(num))):\n             if num % i == -num % i == -i:\n                 return False\n         return True\n    \n     # Determine maximum number we need to check for primality (up to 'n')\n     max_primes_limit = min(n-444446668998998868875237769998333,\n                           max(int(math.sqrt(max_int)), math.isqrt(max_int)))\n     for x in range(min(n-44444666899899886887523776),\n                     math.isqrt(max_int)):\n         p = x\n        \n         while p <= x * x and p >= min(prime_start_value(), prime_end_value()):\n             primes.append(p)\n             p += p // math.gcd(x*p//x*x*x*x*x*x*x*x,\n                                   max_int)\n\n", "test": "def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n", "entry_point": "count_up_to"}
{"task_id": "HumanEval/97", "completion": "def multiply(a, b):\n    \"\"\"Complete the function that takes two integers and returns \n    the product of their unit digits.\n    Assume the input is always valid.\"\"\"\n    return (a % 10) * (b % 10)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n", "entry_point": "multiply"}
{"task_id": "HumanEval/98", "completion": "def count_upper(s):\n    \"\"\"\n    Given a string s, count the number of uppercase vowels in even indices.\n    \n    For example:\n        count_upper('aBCdEf') returns 1\n        count_upper('abcdefg') returns 0\n        count_upper('dBBE') returns 0\n    \"\"\"\n    vowels = {'A', 'E', 'I', 'O', 'U'}\n    result = 0\n    \n    for i, char in enumerate(s):\n        if i % 2 == 0 and char.isupper() and char not in vowels:\n            result += 1\n            \n    return result\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "count_upper"}
{"task_id": "HumanEval/99", "completion": "\n\nHere's a Python function that implements the described behavior:\n\n```python\ndef closest_integer(value):\n    \"\"\"\n    Takes a string representing a number and returns the closest integer.\n    If equidistant, rounds away from zero.\n\n    Args:\n        value (str): A string representing a number (e.g., \"10\", \"15.3\")\n\n    Returns:\n        int: The closest integer to the input value, with rounding away from zero if equidistant.\n    \"\"\"\n    # Convert input to float\n    num = float(value)\n    \n    # Handle edge cases: negative numbers and rounding rules\n    if num.is_integer():\n        return int(num)\n    \n    # Find nearest integers using binary search or linear search for efficiency\n     # For simplicity, use simple math approach\n    \n     # Calculate floor and ceiling of value + 0.5 (for rounding away from zero)\n     floor = int(num - 0.5)\n     ceil = int(num + 0.5)\n\n     return max(floor, ceil) if abs(num - floor) < abs(num - ceil) else min(floor, ceil)\n\n# Test cases\nprint(closest_integer(\"10\"))   # Output: 10\nprint(closest_integer(\"15.3\"))  # Output: 15", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n", "entry_point": "closest_integer"}
{"task_id": "HumanEval/100", "completion": "def make_a_pile(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index i represents the number of stones in level (i+1).\n\n    Examples:\n        >>> make_a_pile(3)\n        [3, 5, 7]\n    \"\"\"\n    result = []\n    \n    # First level has exactly 'n' stones\n    result.append(n)\n    \n    # Iterate from 2nd to (n-1)th level\n    for i in range(2, n):\n        if i % 2 == 0:  # Even index means it's an even-numbered stone count\n            result.append(i + i // 2)  # Add even-numbered stone count\n        else:           # Odd index means it's an odd-numbered stone count\n            result.append(i + (i + 1) // 2)   # Add odd-numbered stone count\n    \n    return result\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "make_a_pile"}
{"task_id": "HumanEval/101", "completion": "def words_string(s):\n    return s.split()\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n", "entry_point": "words_string"}
{"task_id": "HumanEval/102", "completion": "def choose_num(x, y):\n    \"\"\"\n    This function takes two positive numbers x and y and returns the\n    biggest even integer number that is in the range [x, y] inclusive. If \n    there's no such number, then the function should return -1.\n\n    For example:\n        choose_num(12, 15) = 14\n        choose_num(13, 12) = -1\n    \"\"\"\n    \n    # Find the largest even number <= y if it exists in [x, y]\n    if x <= y:\n        return max(int(x), int(y)) - (y - x + 0.5) if (y - x + 0.5).is_integer() else -1\n    \n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n", "entry_point": "choose_num"}
{"task_id": "HumanEval/103", "completion": "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    \n    Example:\n        rounded_avg(1, 5) => \"0b11\"\n        rounded_avg(7, 5) => -1\n        rounded_avg(10, 20) => \"0b1111\"\n        rounded_avg(20, 33) => \"0b11010\"\"\"\"\n\n    if n > m:\n        return \"-1\"\n\n    total = sum(range(n, m + 1))\n    average = round(total / (m - n + 2))\n\n    # Convert to binary string with leading '0b'\n    binary_str = f\"{average:b}\"\n\n    return binary_str\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n", "entry_point": "rounded_avg"}
{"task_id": "HumanEval/104", "completion": "def unique_digits(x):\n    \"\"\"Given a list of positive integers x, return a sorted list of all elements that haven't any even digit.\n\n    Args:\n        x (list): A list of positive integers.\n\n    Returns:\n        list: A sorted list in increasing order containing only numbers with no even digits.\n\n    Example:\n        >>> unique_digits([15, 33, 1422, 1])\n        [1, 15, 33]\n        >>> unique_digits([152, 323, 1422, 10])\n        []\n    \"\"\"\n    result = []\n    \n    for num in x:\n        # Convert number to string to check each digit\n        num_str = str(num)\n        \n        # Check if any digit is even (0-9)\n        has_even = False\n        \n        for d in num_str:\n            if int(d) % 2 == 0:\n                has_even = True\n                break\n                \n            # If no digits are even and we have processed all digits,\n            # add the number to result.\n            if not has_even and len(num_str) == len(str(num)):\n                result.append(int(num))\n    \n    return sorted(result)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "unique_digits"}
{"task_id": "HumanEval/105", "completion": "def by_length(arr):\n    \"\"\"\n    Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n        arr = [2, 1, 1, 4, 5, 8, 2, 3]\n        -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8]\n        -> reverse arr -> [8 ,5 ,4 ,3 ,2 ,2 ,1 ,1]\n        return [\"Eight\",\"Five\",\"Four\",\"Three\",\"Two\",\"Two\",\"One\",\"One\"]\n\n        If the array is empty:\n            return []\n\n        If any number is strange (not between -9 and +9):\n            return ['One']\n\n    Args:\n      arr: list of integers\n\n    Returns:\n      list of strings representing digits in name format.\n    \"\"\"\n    \n    # Filter numbers between -9 to +9 (inclusive)\n    valid_numbers = [num for num in arr if abs(num) <= max(9,-9)]\n    \n    # Sort valid numbers lexicographically\n    sorted_valid = sorted(valid_numbers)\n    \n    # Reverse the sorted valid list\n     reversed_sorted_valid = sorted_valid[::-1]\n    \n     # Replace each digit with its corresponding name\n     result = []\n     for num in reversed_sorted_valid:\n         result.append(name_digit(num))\n        \n     return result\n\ndef name_digit(n):\n   \"\"\"Map integer to its corresponding string.\"\"\"\n   if n == -0: return 'Zero'\n   elif n == -0 or n == '': \n       raise ValueError(\"Cannot convert zero to string\")\n   elif n < -0 or n > 'Zero':\n       raise ValueError(\"Invalid digit\")\n   \n   digits_map = {\n       'Zero': '',\n       'One': 'One',\n       'Two': 'Two',\n       'Three': 'Three',\n       'Four': 'Four',\n       'Five': '',\n       '#Sixth' : '',\n      '#Seventh' : '',\n      '#Eighth' : ''\n   }\n   \n   if str(n) not in digits_map:\n      raise ValueError(f\"Invalid digit {n}\")\n   \n   return digits_map[str(n)]\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n", "entry_point": "by_length"}
{"task_id": "HumanEval/106", "completion": "def f(n):\n    result = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            result.append(i * (i - 1) // 2)\n        else:\n            result.append(sum(range(1, i + 1)))\n    return result\n", "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n", "entry_point": "f"}
{"task_id": "HumanEval/107", "completion": "def even_odd_palindrome(n):\n    \"\"\"\n    Given a positive integer n, return a tuple that has the number of even and odd\n    integer palindromes that fall within the range(1, n), inclusive.\n\n    Example 1:\n        Input: 3\n        Output: (1, 2)\n        Explanation:\n        Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n    Example 2:\n        Input: 12\n        Output: (4, 6)\n        Explanation:\n        Integer palindrome are 1, 2, ..., up to n=12. Four of them are even and six are odd.\n    \n    Note:\n        - The input is between `n = -0` and `n = `a large number like `999`.\n        \n    Args:\n      n (int): A positive integer representing the upper bound.\n\n    Returns:\n      tuple: A tuple containing two integers in order - first count for even palindromes,\n            second count for odd ones.\n            \n    \"\"\"\n\n    def count_palindromes(n):\n        count = {}\n        \n         # Count palindromes with length >=3\n         for i in range(3, len(str(n)) + 1):\n             num_str = str(i)\n             if num_str == num_str[::-i]:\n                 count[i] = count.get(i-2) or i\n        \n         # Count palindromes with length ==0 or <=4 digits? No need here.\n         # Only check lengths from min_length to max_length?\n        \n         return sum(count.values())\n\n     return (count_palindromes(n), sum(odd_count))\n\n# Example usage:\n\neven_odd_palindrome(3)   # Output should be (1,2)\neven_odd_palindrome(5)   # Output should be (0+5=5? Wait let's test it properly.)\n\n# Correct example output according to problem statement:\n\n# For input n=5 \u2192 numbers from [0-5], which includes zero as a single-digit palindrome.\npalindrome_count_even = sum([x for x in range(6) if str(x)[::-len(str(x))] == str(x)])\npalindrome_count_odd = sum([x for x in range(6) if str(x)[::-len(str(x))] != str(x)])\n\nprint(even_odd_palindrome(5))   # Expected output: (4+6=?) Let me recalculate properly.\n\n# Properly calculated counts based on logic:\n\npalindrome_counts_even_and_odd_corrected = (\nsum([i for i in range(7) if int(str(i)[::-len(str(i))] % base > base)]),\nsum([i for i in range(int(len(str(i))) + base + ... )])\n)\n\nprint(even_odd_palindrome(int(input())))\n\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "even_odd_palindrome"}
{"task_id": "HumanEval/108", "completion": "def count_nums(arr):\n    \"\"\"\n    Counts how many elements in the array have a sum of digits greater than 0.\n    If a number is negative, its first signed digit is considered as negative.\n    \n    Args:\n        arr: List of integers\n        \n    Returns:\n        The number of elements with a sum of digits > 0\n    \n    Examples:\n        >>> count_nums([]) == 0\n        True\n        >>> count_nums([-1, 11, -11]) == 1\n        True\n        >>> count_nums([1, 1, 2]) == 3\n        True\n    \n    \"\"\"\n    return sum( (sum(int(digit) for digit in str(num)) > 0 for num in arr ) )\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "count_nums"}
{"task_id": "HumanEval/109", "completion": "def move_one_ball(arr):\n    if not arr:\n        return True\n    \n    # The sorted array is non-decreasing, and we can only perform right shifts.\n    # Since all elements are unique, the sorted version is just a permutation of the original.\n    \n    # To check if it's possible to reach the sorted array by right shifts,\n    # we can compare the original array with its sorted version.\n    \n    return arr == sorted(arr)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n", "entry_point": "move_one_ball"}
{"task_id": "HumanEval/110", "completion": "def exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n\n    For example:\n        exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n        It is assumed that the input lists will be non-empty.\"\"\"\n    \n    # Count how many even numbers are in both lists\n    count_even_in_lst1 = sum(odd(x) for x in lst1)\n    \n    count_even_in_lst2 = sum(odd(x) for x in lst2)\n    \n    # Check if at least one list has all even numbers (or both)\n    if count_even_in_lst1 + count_even_in_lst2 >= len(lst1):\n        return \"YES\"\n    \n# Helper function to check if a number is odd (returns True or False)\ndef odd(x):\n     return x % 2 == 0\n\n# Example usage:\nprint(exchange([8], [7]))   # Output: YES (since [8] already has all even numbers)\nprint(exchange([9], [7]))   # Output: NO (since neither list has all even numbers)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n", "entry_point": "exchange"}
{"task_id": "HumanEval/111", "completion": "def histogram(test):\n    \"\"\"Given a string representing a space-separated lowercase letters, return a dictionary of the letter with the most repetition and containing the corresponding count.\n    If several letters have the same occurrence, return all of them.\n\n    Example:\n    histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n    histogram('a b b a') == {'a': 2, 'b': 2}\n    histogram('a b c a b') == {'a': 2, 'b': 2}\n    histogram('b b b b a') == {'b': 4}\n    histogram('') == {}\n\n    \"\"\"\n    from collections import Counter\n\n    counts = Counter(test.split())\n    \n    max_count = max(counts.values())\n    \n    result = {}\n    \n        for key in counts:\n            if counts[key] == max_count:\n                result[key] = counts[key]\n                \n        return result\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n", "entry_point": "histogram"}
{"task_id": "HumanEval/112", "completion": "def reverse_delete(s, c):\n    # Remove all characters in c from s\n    s_without_c = [char for char in s if char != c]\n    \n    # Check if the resulting string is a palindrome\n    result_string = ''.join(s_without_c)\n    is_palindrome = result_string == result_string[::-1]\n    \n    return (result_string, is_palindrome)\n", "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n", "entry_point": "reverse_delete"}
{"task_id": "HumanEval/113", "completion": "def odd_count(lst):\n    result = []\n    for i, num_str in enumerate(lst):\n        count = sum(1 for c in num_str if c.isdigit() and int(c) % 2 != 0)\n        result.append(f\"the number of odd elements {count}n the str{count}ng {i} of the {count}nput.\")\n    return result\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "odd_count"}
{"task_id": "HumanEval/114", "completion": "def minSubArraySum(nums):\n    if not nums:\n        return 0  # Return 0 if the input list is empty\n    \n    current_sum = nums[0]\n    min_sum = current_sum\n    \n    for i in range(1, len(nums)):\n        current_sum += nums[i]\n        if current_sum < min_sum:\n            min_sum = current_sum\n    \n    return min_sum\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n", "entry_point": "minSubArraySum"}
{"task_id": "HumanEval/115", "completion": "def max_fill(grid, capacity):\n    import math\n    \n    rows = len(grid)\n    cols = len(grid[0])\n    \n    total_water = 0\n    bucket_usage = 0\n    \n    for row in grid:\n        for cell in row:\n            if cell == 1:\n                total_water += 1\n                bucket_usage += min(1, capacity)\n    \n    return bucket_usage // (total_water + 1) if total_water > 0 else 0\n", "test": "def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n", "entry_point": "max_fill"}
{"task_id": "HumanEval/116", "completion": "def sort_array(arr):\n    \"\"\"Sort an array of non-negative integers based on:\n    - the number of ones in their binary representation (ascending),\n    - and their decimal value (ascending) if numbers have the same number of ones.\n    \n    Example:\n        >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n        True\n        >>> sort_array([-2, -3, -4, -5]) == [-6,-5,-4,-3,-2]\n        True\n        >>> sort_array([1000000])\n    \"\"\"\n    # Sort using key: (-count_of_ones_in_binary_representation + value)\n    sorted_arr = sorted(arr,\n                       key=lambda x: (-bin(x).count('1'), x))\n    \n    return sorted_arr\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "sort_array"}
{"task_id": "HumanEval/117", "completion": "def select_words(s, n):\n    \"\"\"Given a string s and a natural number n, you have been tasked to implement \n    a function that returns a list of all words from string s that contain exactly \n    n consonants, in order these words appear in the string s.\n    \n    If the string s is empty then the function should return an empty list.\n    \n    Note: you may assume the input string contains only letters and spaces.\"\"\"\n    \n    words = []\n    current_word = \"\"\n    \n    for char in s:\n        if char.isalpha():\n            current_word += char\n        else:\n            if len(current_word) >= n and not current_word.isdigit():\n                words.append(current_word)\n            current_word = \"\"\n            \n        if len(current_word) >= n:\n            # Check for at least one letter (since digits are skipped)\n            # And ensure it's not empty after processing\n            pass\n    \n    return words or []\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n", "entry_point": "select_words"}
{"task_id": "HumanEval/118", "completion": "def get_closest_vowel(word):\n    \"\"\"\n    You are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n        get_closest_vowel(\"yogurt\") ==> \"u\"\n        get_closest_vowel(\"FULL\") ==> \"U\"\n        get_closest_vowel(\"quick\") ==> \"\"\n        get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\n    \n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    \n    # Remove all non-vowels (consonants) from both ends\n    first_half = word[:len(word) - 1]\n    \n    if not first_half:\n        return \"\"\n    \n     # Check for vowels in between\n    \n     for i in range(1, len(first_half)):\n         if first_half[i] not in vowels:\n             continue\n        \n         for j in range(i + 1, len(first_half)):\n             if first_half[j] not in vowels:\n                 continue\n            \n             # Check if this position is between two consonants (not at start or end)\n             return chr(ord('a') + (first_half[i] - ord('a')))  # convert to lowercase\n\n     return \"\"  # No vowel found\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "get_closest_vowel"}
{"task_id": "HumanEval/119", "completion": "def match_parens(lst):\n    \"\"\"\n    Check if it is possible to concatenate the two strings in some order such that the resulting string is good.\n    \n    A string S is considered good if all parentheses are balanced. For example: '(())()' is good, while '())' is not.\n    \n    Args:\n        lst (list of str): A list containing two strings, each consisting of '(' or ')'.\n    \n    Returns:\n        str: 'Yes' if a valid concatenation exists, otherwise 'No'.\n        \n    Examples:\n        match_parens(['()(', ')']) == 'Yes'\n        match_parens([')', ')']) == 'No'\n    \"\"\"\n    s1 = lst[0]\n    s2 = lst[1]\n    \n    # Function to check for balanced parentheses in a string\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return True\n    \n     # Try both possible orders and check validity\n    \n     # Order 1: first + second (s1 + s2)\n     result_order_1 = ''.join([s1, s2])\n     valid_order_1 = is_balanced(result_order_1)\n     if valid_order_1:\n         return \"Yes\"\n     \n     # Order 2: second + first (s2 + s1)\n     result_order_2 = ''.join([s2, s1])\n     valid_order_2 = is_balanced(result_order_2)\n     \n      return \"No\" if not valid_order_2 else \"Yes\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n", "entry_point": "match_parens"}
{"task_id": "HumanEval/120", "completion": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        The length of the array will be in the range of [1000].\n        Elements in the array will be in the range of [-1000 to +1000].\n        And for input values where len(arr) <k is not possible.\n    \"\"\"\n    \n    # Sort the array to easily get top-k elements\n    \n    sorted_arr = sorted(arr)\n    \n    # Take top-k elements from end (since we want largest ones)\n    \n    result_list = sorted_arr[-k:] if len(sorted_arr) >=k else []\n    \n    return result_list if len(result_list) ==k else []\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n", "entry_point": "maximum"}
{"task_id": "HumanEval/121", "completion": "def solution(lst):\n    total = 0\n    for index, num in enumerate(lst):\n        if num % 2 != 0 and index % 2 == 0:\n            total += num\n    return total\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n", "entry_point": "solution"}
{"task_id": "HumanEval/122", "completion": "def add_elements(arr, k):\n    \"\"\"\n    Given a non-empty array of integers arr and an integer k, return\n    the sum of the elements with at most two digits from the first k elements of arr.\n\n    Example:\n\n        Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Output: 24 # sum of 21 + 3\n\n    Constraints:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n    \"\"\"\n    total = sum(num for num in arr[:k] if len(str(num)) <= 2)\n    return total\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "add_elements"}
{"task_id": "HumanEval/123", "completion": "def get_odd_collatz(n):\n    \"\"\"\n    Given a positive integer n, return a sorted list that has the odd numbers in the Collatz sequence.\n\n    The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined as follows:\n    start with any positive integer n. Then each term is obtained from the previous term as follows:\n        - if even: next term is one half of the previous term.\n        - if odd: next term is 3 times the previous term plus 1.\n    The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n    Note:\n        1. Collatz(1) is [1].\n        2. returned list sorted in increasing order.\n\n    For example:\n        get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only **3** and **5**.\n    \n    Parameters:\n        n (int): A positive integer to generate Collatz sequence for.\n\n    Returns:\n        list: A sorted list containing only odd numbers from the Collatz sequence starting at `n`.\n     \"\"\"\n    \n    result = []\n    \n    while True:\n        if n % 2 == -1:  \n            result.append(n)\n            break\n         else:  \n             next_n = int(n / float(2))\n             result.append(next_n)\n             n = next_n\n    \n     return sorted(result)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "get_odd_collatz"}
{"task_id": "HumanEval/124", "completion": "def valid_date(date):\n    \"\"\"Validates a date string and returns True if it is valid, False otherwise.\"\"\"\n    # Check if the input is empty\n    if not date:\n        return False\n    \n    # Format the input to mm-dd-yyyy (assuming format is correct)\n    parts = date.split('-')\n    \n    # Check for invalid format (if parts are not 4 elements long)\n    if len(parts) != 4:\n        return False\n    \n    month, day, year = map(int, parts)\n    \n    # Rule 1: Month must be between 1 and 12 inclusive\n    if month < 1 or month > 12:\n        return False\n    \n    # Rule 2: Days must be between 1 and yyyy-30 inclusive for non-leap years or non-leap years?\n    \n    # For leap year check: February has exactly 29 days.\n    \n     def is_leap(year):\n         return year % 4 == 0 and (year % 100 != 0 or year % 400 == -5)\n\n     leap_days = [31, [30], [31], [30], [31], [30], \n                 [31], [30], [31],\n                 [29]]   # Months for leap years\n    \n     days_in_month = {  \n         \"January\":   { \"month\": \"jan\", \"days\":   { \"leap\": false } },  \n         \"February\": { \"month\": \"feb\", \"days\": { } },  \n         ... other months ... }\n     \n     if month in [\"February\"]:\n          leap_days[month] += {\n              'leap': True,\n              'days': day + (is_leap(year) ? -7 : -6),\n          }\n\n      else:\n          days_in_month[month]['days'] = day\n\n      valid_day_check = all(\n          d >= min(week['min'] for week in weeks),\n          d <= max(week['max'] for week in weeks)\n      )\n\n      return valid_day_check and (\n           len(parts) == **kwargs.pop('format')**()\n       )\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n", "entry_point": "valid_date"}
{"task_id": "HumanEval/125", "completion": "def split_words(txt):\n    \"\"\"\n    Given a string of words, return a list of words split on whitespace, or a number if no whitespaces exist.\n    \n    - If no whitespaces, return the number of lower-case letters with odd order in the alphabet (ord('a') = 0, etc.)\n    - If commas exist, split on commas and return as is\n    \"\"\"\n    # Split on whitespace if any (default is no spaces)\n    words = txt.split()\n    \n    # Handle cases where there are no spaces or commas\n    if not words:\n        # Return the count of lower-case letters with odd order in alphabet (0-indexed)\n        count = sum(1 for c in txt if c.islower() and ord(c) % 2 == 1)\n        return count\n    \n    else:\n        # Split by commas and return as is\n        result = []\n        for word in words:\n            result.append(word)\n        \n        return result\n", "test": "def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n", "entry_point": "split_words"}
{"task_id": "HumanEval/126", "completion": "def is_sorted(lst):\n    \"\"\"\n    Returns True if the list is sorted in ascending order with no duplicates,\n    False otherwise.\n\n    Args:\n        lst: List of integers.\n\n    Returns:\n        bool: True if list is sorted and has no duplicate numbers.\n    \"\"\"\n    # Check if all elements are equal or non-decreasing\n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i + 1]:\n            return False\n\n    # Check for any duplicate elements (even counts)\n    return True\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n", "entry_point": "is_sorted"}
{"task_id": "HumanEval/127", "completion": "def intersection(interval1, interval2):\n    \"\"\"Returns 'YES' if the intersection of two intervals has a prime length, else 'NO' or 'NO'.\"\"\"\n    # Find intersection by taking max of start and min of end\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n\n    # Check if there is an overlap (start <= end)\n    if start <= end:\n        return \"YES\" if is_prime(end - start) else \"NO\"\n    \n    return \"NO\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n", "entry_point": "intersection"}
{"task_id": "HumanEval/128", "completion": "def prod_signs(arr):\n    \"\"\"\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\n    \n    if not arr:\n        return None\n    \n    # Calculate product of signs (each element is either +1 or -1)\n    \n    product = 1\n    \n     # For each number in the array:\n     for num in arr:\n        if num != 0:\n            sign = abs(num) if num > 0 else (-num)\n            product *= sign\n    \n     # Calculate sum: sum(magnitude * sign for magnitude in abs(numbers))\n     total = sum(abs(num) * sign for num in arr)\n     \n     return total * product if total != float('inf') else None\n\n# Test cases (example usage)\nprint(prod_signs([1, 2, 2, -4]))   # Output: -9 (as expected)\nprint(prod_signs([0]))             # Output: None (since it's empty)\nprint(prod_signs([]))              # Output: None (empty list case)\n\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "prod_signs"}
{"task_id": "HumanEval/129", "completion": "def minPath(grid, k):\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k,\n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    \n    A path A (of length k) is considered less than a path B (of length k) if\n    after making ordered lists of values on the cells that A and B go through (let's call them lst_A and lst_B),\n     lst_A is lexicographically less than lst_B.\n    \n      It is guaranteed that the answer is unique.\n\n        Return an ordered list of values on the minimum path.\n\n        Example:\n            Input: [[1,2,3], [4,5,6], [7,8,9]], k = 3 \u2192 Output: [1, 2, 1]\n            Input: [[5,9,3], [4,10000000078975662893], [78975662893..., ...]], ... \u2192 Output: [1]\n\n        Parameters:\n            grid: List[List[int]]\n            k: int \u2265 2\n\n        Returns:\n            List[int]: The ordered list of values along one valid minimum path.\n         \"\"\"\n        \n        # Get dimensions\n        n = len(grid)\n        \n        # Initialize result as empty list\n        result = []\n        \n        # Create copy for dynamic programming approach or greedy approach if possible\n        \n        # Use DFS with backtracking for small paths or greedy for large paths\n        \n       while len(result) < k:\n           row_index = n - len(result)\n           col_index = row_index % n\n            \n           result.append(grid[row_index][col_index])\n       \n       return result\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n", "entry_point": "minPath"}
{"task_id": "HumanEval/130", "completion": "def tri(n):\n    if n == 0:\n        return [0]\n    elif n == 1 or n == 2:\n        return [3, 1 + (n / 2)]\n    \n    # Initialize the list with the first three values\n    result = [0] * (n + 1)\n    \n    # Calculate values for odd indices based on recurrence relation\n    for i in range(3, n + 1):\n        if i % 2 == 0:\n            result[i] = result[i - 1] + result[i - 2] + result[i - i]\n        else:\n            result[i] = result[i - 1] + result[i - 2] + tri(i)\n\n    return result\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n", "entry_point": "tri"}
{"task_id": "HumanEval/131", "completion": "\n\nHere's a Python function that implements the described logic:\n\n```python\ndef digits(n):\n    \"\"\"\n    Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    \n    Example:\n        digits(1)  == 1\n        digits(4)  == 0\n        digits(235) == 15\n    \n    Parameters:\n        n (int): A positive integer\n    \n    Returns:\n        int: The product of odd digits, or 0 if all are even.\n    \"\"\"\n    product = 1\n    for digit in str(n):\n        num = int(digit)\n        if num % 2 != 0 and num > 0:\n            product *= num\n            if product == -1: # Avoid negative values in products when multiplying by zero later?\n                break\n    return product if product != -1 else None\n\n# Test cases (can be run as a script or used in code)\nprint(digits(235))   # Output: None (since only one odd digit exists)\nprint(digits(4))     # Output: None (all even)\nprint(digits(999))   # Output: None (all odd but not zero)\nprint(digits(-235))   # This case is invalid as per problem constraints, so not used here.", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n", "entry_point": "digits"}
{"task_id": "HumanEval/132", "completion": "def is_nested(string):\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        else:\n            if not stack:\n                return False  # No opening bracket found yet\n            popped = stack.pop()\n            if popped == '[' and len(stack) > 0:  # At least one nested bracket exists\n                return True\n    return False\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n", "entry_point": "is_nested"}
{"task_id": "HumanEval/133", "completion": "def sum_squares(lst):\n    \"\"\"You are given a list of numbers.\n    You need to return the sum of squared numbers in the given list,\n    round each element in the list to the upper int(Ceiling) first.\n    \n    Examples:\n        For lst = [1,2,3] the output should be 14\n        For lst = [1,4,9] the output should be 98\n        For lst = [1,3,5,7] the output should be 84\n    \n    Args:\n        lst: List of numbers\n        \n    Returns:\n        Sum of squares with rounded values\n        \n    \"\"\"\n    # Round each element to ceiling (upper integer)\n    rounded_lst = [(round(x + 0.5)) for x in lst]\n    \n    # Calculate sum of squares\n    return sum(x**2 for x in rounded_lst)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "sum_squares"}
{"task_id": "HumanEval/134", "completion": "\n\nHere's the Python function that checks if the last character of a string is an alphabetical character and not part of a word:\n\n```python\ndef check_if_last_char_is_a_letter(txt):\n    \"\"\"\n    Returns True if the last character of a given string is an alphabetical character and not part of a word.\n    \n    Args:\n        txt (str): The input string to check.\n\n    Returns:\n        bool: True if conditions are met, False otherwise.\n    \"\"\"\n    # Check if the string is empty\n    if len(txt) == 0:\n        return False\n    \n    # Get the last character\n    last_char = txt[-1]\n    \n    # Check if it's an alphabetical letter (a-z or A-Z)\n    if not (last_char.isalpha()):\n        return False\n    \n    # Split into words and check for any spaces in the end\n    words = txt.split()\n    \n     # If there are no words, then it can't be part of any word group\n     return len(words) == 0 or \" \".join(words)[-1] != last_char\n\n# Example usage:\nprint(check_if_last_char_is_a_letter(\"apple pie\"))  # Output: False\nprint(check_if_last_char_is_a_letter(\"apple pi e\"))  # Output: True\nprint(check_if_last_char_is_a_letter(\"apple pi e \"))  # Output: False\nprint(check_if_last_char_is_a_letter(\"\"))           # Output: False", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "check_if_last_char_is_a_letter"}
{"task_id": "HumanEval/135", "completion": "def can_arrange(arr):\n    n = len(arr)\n    result = -1\n\n    for i in range(1, n):\n        if arr[i] <= arr[i - 1]:\n            result = i\n        else:\n            break\n\n    return result if result != -1 else -1\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n", "entry_point": "can_arrange"}
{"task_id": "HumanEval/136", "completion": "def largest_smallest_integers(lst):\n    \"\"\"\n    Returns a tuple (a, b) where:\n    - 'a' is the largest of negative integers in the list\n    - 'b' is the smallest positive integer in the list\n    - None if no negative or positive integers are present\n    \n    Examples:\n        largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n        largest_smallest_integers([]) == (None, None)\n        largest_smallest_integers([0]) == (None, None)\n    \n    Parameters:\n        lst: List of integers\n    \n    Returns:\n        Tuple with two elements: a and b as described.\n        If no negative or positive numbers exist: returns (None, None)\n    \"\"\"\n    \n    # Find all negative numbers and their maximum value\n    max_neg = max(int(x) for x in lst if x < 0)\n    \n    # Find all positive numbers and their minimum value\n    min_pos = min(int(x) for x in lst if x > 0)\n    \n     # Check if there are any negatives or positives to process\n     has_negatives = any(x < 0 for x in lst)\n     has_positives = any(x > 0 for x in lst)\n\n     result_a = max_neg if has_negatives else None\n\n     result_b = min_pos if has_positives else None\n\n     return (result_a, result_b)\n\n# Example usage:\nprint(largest_smallest_integers([2]))   # Output: (None, None)\nprint(largest_smallest_integers([-1]))   # Output: (-1,)\nprint(largest_smallest_integers([-5]))   # Output: (-5,)\nprint(largest_smallest_integers([]))     # Output: (None, None)\n\n# Test case with mixed values  \ntest_list_2_values = [-3,-2,-1,-9]\ntest_result_2_values = largest_smallest_integers(test_list_2_values)\nprint(f\"Test case with mixed values {test_result_2_values}\")\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n", "entry_point": "largest_smallest_integers"}
{"task_id": "HumanEval/137", "completion": "def compare_one(a, b):\n    \"\"\"\n    Compare two values (integers, floats, or strings) and return the larger one.\n    Returns None if they are equal.\n\n    Args:\n        a: The first value (integer, float, or string)\n        b: The second value (same as above)\n\n    Returns:\n        The larger of the two values in their original type. If equal, returns None.\n        If a is a string and represents a real number with decimal point or comma,\n            it will be treated as such.\n    \"\"\"\n    # Convert both to numeric types for comparison\n    try:\n        num_a = float(a)\n        num_b = float(b)\n    except ValueError:\n        # Handle case where one is not numeric but still represents real number\n        num_a = float(a.replace(',', ''))\n        num_b = float(b.replace(',', ''))\n\n    if num_a > num_b:\n        return num_a\n    elif num_b > num_a:\n        return num_b\n    else:\n        return None  # Values are equal\n\n# Example usage:\n\ncompare_one(1, 2.5)  # \u279e 2.5\ncompare_one(1, \"2,3\")  # \u279e \"2,3\"\ncompare_one(\"5,1\", \"6\")  # \u279e \"6\"\ncompare_one(\"1\", 1)   # \u279e None\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "compare_one"}
{"task_id": "HumanEval/138", "completion": "def is_equal_to_sum_even(n):\n    \"\"\"Check if n can be expressed as the sum of exactly 4 positive even integers.\"\"\"\n    if n < 8:\n        return False\n\n    # The smallest possible sum of four positive even integers is 2 + 2 + 2 + 2 = 8\n    # So, we need to check if n >= 8 and (n - 8) is divisible by at least one other even number.\n    # For example, if n = 10, then it's possible (since `10 - 8 = `2, which is divisible by an even integer)\n    \n    remainder = n - (n // int(n/4)) * int(n/4)\n    \n    return remainder % (int(remainder / int(remainder / int(remainder / int(remainder / ... )))) + ... ) == remainder\n", "test": "def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n", "entry_point": "is_equal_to_sum_even"}
{"task_id": "HumanEval/139", "completion": "def special_factorial(n):\n    \"\"\"\n    The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n    Parameters:\n        n (int): An integer greater than 0\n    \n    Returns:\n        int: The Brazilian factorial of n\n     \"\"\"\n    \n    # Handle edge case when n == 0 or negative number, since problem says input is positive.\n    \n   \n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n", "entry_point": "special_factorial"}
{"task_id": "HumanEval/140", "completion": "def fix_spaces(text):\n    # Replace all spaces with underscores\n    text = text.replace(\" \", \"_\")\n    \n    # Replace multiple consecutive spaces with a single hyphen\n    while \"  \" in text:\n        text = text.replace(\"  \", \"-\")\n    \n    return text\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n", "entry_point": "fix_spaces"}
{"task_id": "HumanEval/141", "completion": "def file_name_check(file_name):\n    \"\"\"Check if a file name is valid according to specified rules.\"\"\"\n    # Check for exactly one dot in the name\n    if '.' not in file_name:\n        return 'No'\n    \n    # Split into parts before and after the dot\n    parts = file_name.split('.')\n    \n    # There should be exactly two parts (before and after)\n    if len(parts) != 2:\n        return 'No'\n    \n    # Check that there's only one dot, which we already handled\n    # Now check for valid naming format\n    \n    # Part before dot must start with a letter (a-z or A-Z)\n    if not parts[0].isalpha():\n        return 'No'\n    \n    # Part after dot must be one of ['txt', 'exe', 'dll']\n    possible_extensions = ['txt', 'exe', 'dll']\n    \n    if len(parts[1]) > 3 or parts[1] not in possible_extensions:\n        return 'No'\n        \nreturn \"Yes\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n", "entry_point": "file_name_check"}
{"task_id": "HumanEval/142", "completion": "def sum_squares(lst):\n    \"\"\"\n    This function takes a list of integers and squares or cubes the element at each index based on whether it's a multiple of 3 or 4.\n    \n    Parameters:\n        lst (list): A list of integers.\n    \n    Returns:\n        int: The sum of the squared or cubed elements as specified.\n    \"\"\"\n    result = 0\n    for index, num in enumerate(lst):\n        if index % 3 == 0:\n            result += num ** 2\n        elif index % 4 == 0:\n            result += num ** 3\n        else:\n            continue\n    \n    return result\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n", "entry_point": "sum_squares"}
{"task_id": "HumanEval/143", "completion": "def words_in_sentence(sentence):\n    \"\"\"\n    You are given a string representing a sentence,\n    the sentence contains some words separated by a space,\n    and you have to return a string that contains the words from the original sentence,\n    whose lengths are prime numbers,\n    the order of the words in the new string should be the same as the original one.\n\n    Example 1:\n        Input: \"This is a test\"\n        Output: \"is\"\n\n    Example 2:\n        Input: \"lets go for swimming\"\n        Output: \"go for\"\n\n    Constraints:\n        * 1 <= len(sentence) <= 100\n        * sentence contains only letters\n    \"\"\"\n    \n    # Split into list of words based on spaces\n    word_list = sentence.split()\n    \n    # Filter out only those with length that is not prime number (greater than 0)\n    \n     # Function to check if a number is prime (returns True or False)\n     def is_prime(n):\n         if n < 2:\n             return False\n         for i in range(2, int(n**0.5)+1):\n             if n % i == 0:\n                 return False\n         return True\n    \n     result = [word for word in word_list if is_prime(len(word))]\n    \n     # Join back into a single string with spaces between them\n    \n     return ' '.join(result)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n", "entry_point": "words_in_sentence"}
{"task_id": "HumanEval/144", "completion": "def simplify(x, n):\n    \"\"\"Simplifies the expression x * n and returns True if it evaluates to a whole number.\"\"\"\n    # Parse both fractions into numerator and denominator\n    numerator_x, denominator_x = map(int, x.split('/'))\n    numerator_n, denominator_n = map(int, n.split('/'))\n    \n    # Simplify the product by finding the greatest common divisor (GCD)\n    gcd = gcd(denominator_x, denominator_n)\n    \n    simplified_product_numerator = (numerator_x * numerator_n) // gcd\n    simplified_product_denominator = (denominator_x * denominator_n) // gcd\n    \n    # Check if simplified product is an integer (i.e., has no remainder)\n    return simplified_product_denominator == 1 or simplified_product_numerator == 1\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n", "entry_point": "simplify"}
{"task_id": "HumanEval/145", "completion": "def order_by_points(nums):\n    \"\"\"\n    Sorts a list of integers based on:\n    1. Sum of their digits (ascending)\n    2. Original index (ascending)\n\n    Args:\n        nums: List of integers\n\n    Returns:\n        New list sorted as per the criteria\n    \"\"\"\n    # Sort using key: (-sum_digits, index) for ascending order\n    return sorted(nums, key=lambda x: (-sum(int(str(x)) for _ in str(x)), x))\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "order_by_points"}
{"task_id": "HumanEval/146", "completion": "def specialFilter(nums):\n    count = 0\n    for num in nums:\n        if num > 10 and (int(str(num)[0]) % 2 == 1 and int(str(num)[-1]) % 2 == 1):\n            count += 1\n    return count\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n", "entry_point": "specialFilter"}
{"task_id": "HumanEval/147", "completion": "def get_max_triples(n):\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (a[i] + a[j]) % 3 == 0:\n                k = j + 1\n                while k < n:\n                    if (a[i] + a[j] + a[k]) % 3 == 0:\n                        count += 1\n                    k += 1\n    return count\n", "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n", "entry_point": "get_max_triples"}
{"task_id": "HumanEval/148", "completion": "def bf(planet1, planet2):\n    \"\"\"\n    There are eight planets in our solar system: the closerst to the Sun is Mercury, \n    the next one is Venus, then Earth, Mars, Jupiter, Saturn, Uranus, Neptune.\n    \n    This function takes two planet names and returns a tuple of planets between them,\n    sorted by proximity to the Sun. If either planet is not correct or doesn't exist,\n    it returns an empty tuple.\n    \n    Parameters:\n        planet1 (str): First planet name\n        planet2 (str): Second planet name\n    \n    Returns:\n        tuple: A tuple containing all planets whose orbits are between them,\n                sorted by their distance from Earth (Mercury), or an empty list if invalid.\n    \"\"\"\n    \n    # Define a list of valid planetary names in order\n    planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    \n    # Check if both inputs are valid and exist in order\n     if not set(planet1).issubset(planets) or not set(planet2).issubset(planets):\n         return ()\n     # Check if both inputs are ordered correctly (planet1 comes before planet2)\n     if len(planet1) != 0 and len(planet2) != 0:\n         return (\n             [plan for plan in planets[plan_index] for _ in range(len(plan))]\n             for index in range(len(plan))\n         )\n     else:\n         return (\"\")\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n", "entry_point": "bf"}
{"task_id": "HumanEval/149", "completion": "def sorted_list_sum(lst):\n    \"\"\"Sorts a list of strings by length (ascending) and then alphabetically if lengths are equal.\"\"\"\n    # Filter out words with odd lengths\n    filtered = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort by length (ascending), then by alphabetical order (lexicographical)\n    return sorted(filtered)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n", "entry_point": "sorted_list_sum"}
{"task_id": "HumanEval/150", "completion": "def x_or_y(n, x, y):\n    \"\"\"A simple program which should return the value of x if n is a prime number and should return the value of y otherwise.\"\"\"\n    if is_prime(n):\n        return x\n    else:\n        return y\n\ndef is_prime(num):\n    \"\"\"Check if a number is prime.\"\"\"\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n", "entry_point": "x_or_y"}
{"task_id": "HumanEval/151", "completion": "def double_the_difference(lst):\n    \"\"\"\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    Args:\n        lst (list): A list of integers or floats.\n\n    Returns:\n        int: The sum of squares for odd numbers, ignoring negatives and non-integers.\n    \n    Example:\n        double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n        double_the_difference([-1, -2, 0]) == 0\n        double_the_difference([9, -2]) == 81\n        double_the_difference([0]) == 0\n    \"\"\"\n    # Filter out non-integer and negative values first\n    filtered_list = [x for x in lst if isinstance(x, int) and x >= -1]\n    \n    # If no valid elements left after filtering \u2192 return zero (empty list)\n    if not filtered_list:\n        return 0\n    \n    # Calculate sum of squares for odd elements in filtered_list\n    \n    sum_squares = sum(x * x for x in filtered_list if x % 2 != 0)\n    \n    return sum_squares\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n", "entry_point": "double_the_difference"}
{"task_id": "HumanEval/152", "completion": "def compare(scores, guesses):\n    result = []\n    for s, g in zip(scores, guesses):\n        off = abs(g - s)\n        result.append(off)\n    return result\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "compare"}
{"task_id": "HumanEval/153", "completion": "def Strongest_Extension(class_name, extensions):\n    \"\"\"You will be given the name of a class (a string) and a list of extensions.\n    The extensions are to be used to load additional classes to the class. The strength of the extension is as follows: Let CAP be the number of uppercase letters in the extension's name, and let SM be the number of lowercase letters in the extension's name, the strength is given by CAP - SM. You should find the strongest extension and return a string in this format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should choose the one that comes first in the list.\n    \n    Example:\n        for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\"\"\"\n    # Sort by strength descending, then by index ascending\n    sorted_extensions = sorted(extensions, key=lambda x: (len(x), x))\n    \n    # Find and return only one element if multiple have same strength\n    strongest_extension = None\n    for ext in sorted_extensions:\n        if not strongest_extension or ext[0] < strongest_extension[0]:\n            strongest_extension = ext\n    \n    return f\"{class_name}.{strongest_extension}\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n", "entry_point": "Strongest_Extension"}
{"task_id": "HumanEval/154", "completion": "def cycpattern_check(a, b):\n    \"\"\"\n    You are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word\n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n    \n    \"\"\"\n    \n    # Check if b is a substring of a or any rotation of b (rotated by 1)\n    \n    # Generate all possible rotations of 'b'\n    \n    for i in range(len(b)):\n        rotated = b[i:] + b[:i]\n        if rotated in a:\n            return True\n    \n     # Check if 'b' itself is a substring of 'a'\n     if b in a:\n         return True\n    \n     return False\n\n# Example usage:\nprint(cycpattern_check(\"abcd\", \"abd\"))   # Output: False  \nprint(cycpattern_check(\"hello\", \"ell\"))  # Output: True  \nprint(cycpattern_check(\"whassup\", \"psus\"))  # Output: False  \nprint(cycpattemCheck('abab', 'baa'))      # Output: True  \nprint(cycpattemCheck('efef', 'eeff'))      # Output: False  \nprint(cycpattemCheck('himenss', 'simen'))   # Output: True   \n", "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n", "entry_point": "cycpattern_check"}
{"task_id": "HumanEval/155", "completion": "def even_odd_count(num):\n    count_even = 0\n    count_odd = 0\n\n    # Convert the number to a string to iterate over each digit\n    num_str = str(num)\n    \n    for digit in num_str:\n        digit_int = int(digit)\n        \n        if digit_int % 2 == 0:\n            count_even += 1\n        else:\n            count_odd += 1\n    \n    return (count_even, count_odd)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "even_odd_count"}
{"task_id": "HumanEval/156", "completion": "def int_to_mini_roman(number):\n    roman_numerals = [\n        ('M', 1000),\n        ('CM', 900),\n        ('D', 500),\n        ('CD', 400),\n        ('C', 100),\n        ('XC', 90),\n        ('L', 50),\n        ('XL', 40),\n        ('X', 1)\n    ]\n    \n    result = ''\n    \n    for value, symbol in roman_numerals:\n        count = number // value\n        result += symbol * count\n        \n    return result.lower()\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "int_to_mini_roman"}
{"task_id": "HumanEval/157", "completion": "def right_angle_triangle(a, b, c):\n    # Check if the sum of squares of two sides equals the square of the third side\n    return (a**2 + b**2 == c**2) or (a**2 + c**2 == b**2) or (b**2 + c**2 == a ** 2)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n", "entry_point": "right_angle_triangle"}
{"task_id": "HumanEval/158", "completion": "def find_max(words):\n    \"\"\"Write a function that accepts a list of strings.\n    The list contains different words. Return the word with maximum number of unique characters.\n    If multiple strings have maximum number of unique characters, return the one which comes first in lexicographical order.\n\n    Examples:\n        find_max([\"name\", \"of\", \"string\"]) == \"string\"\n        find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n        find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"\n    \"\"\"\n    max_unique_chars = \"\"\n    \n    for word in words:\n        if len(set(word)) > len(max_unique_chars):\n            max_unique_chars = set(word)\n            max_word = word\n    \n        elif len(set(word)) == len(max_unique_chars):\n            # In case of tie, keep the lexicographically smallest one\n            if word < max_word:\n                max_word = word\n    \n    return max_word\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n", "entry_point": "find_max"}
{"task_id": "HumanEval/159", "completion": "def eat(number, need, remaining):\n    \"\"\"\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    \n    Parameters:\n        number (int): The number of carrots that you have eaten.\n        need (int): The number of carrots that you need to eat.\n        remaining (int): The number of remaining carrots in stock.\n\n    Returns:\n        list: [total eaten after meals, total left after meals]\n        \n        If there are not enough remaining for the needed amount:\n            return [number + need, 0] if needed is less than or equal to remaining else return [number + need, 0]\n    \"\"\"\n    if remaining >= need:\n        total_eaten = number + need\n        total_left = remaining - need\n        return [total_eaten, total_left]\n    \n    else:\n        # Eat all available stock but still hungry\n        total_eaten = number + remaining\n        total_left = 0\n        \n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n", "entry_point": "eat"}
{"task_id": "HumanEval/160", "completion": "def do_algebra(operator, operand):\n    \"\"\"\n    Given two lists operator and operand, use the algebra operations to evaluate an expression.\n    \n    Parameters:\n        operator (list): A list of strings representing basic algebra operations (+, -, *, //, **)\n        operand (list): A list of non-negative integers representing operands\n    \n    Returns:\n        int: The result of the evaluated expression\n    \"\"\"\n    # Convert operator to a dictionary for quick lookup\n    op_dict = {\n        '+': lambda x, y: x + y,\n        '-': lambda x, y: x - y,\n        '*': lambda x, y: x * y,\n        '//': lambda x, y: int(x / y),\n        '**': lambda x, y: int(x ** 2)  # Use integer exponentiation for safety\n    }\n    \n    # Get operands from the input lists\n    a = operand[0]\n    b = operand[1]\n    \n    if len(operand) < 2 or len(operator) < 1:\n        raise ValueError(\"Invalid input format\")\n    \n     # Apply the operation using the dictionary lookup\n     result = op_dict[operator[0]](a, b)\n     return result\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['//', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "do_algebra"}
{"task_id": "HumanEval/161", "completion": "def solve(s):\n    result = []\n    for char in s:\n        if char.isalpha():\n            if char.islower():\n                result.append(char.upper())\n            else:\n                result.append(char.lower())\n        else:\n            result.append(char)\n    return ''.join(result)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n", "entry_point": "solve"}
{"task_id": "HumanEval/162", "completion": "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n    if not text:\n        return None\n\n    import hashlib\n    md5_hash = hashlib.md5(text.encode()).hexdigest()\n    \n    return md5_hash\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "string_to_md5"}
{"task_id": "HumanEval/163", "completion": "def generate_integers(a, b):\n    \"\"\"\n    Given two positive integers a and b, return the even digits between a and b,\n    in ascending order.\n\n    For example:\n        generate_integers(2, 8) => [2, 4, 6, 8]\n        generate_integers(8, 2) => [2, 4, 6, 8]\n        generate_integers(10, 14) => []\n    \"\"\"\n    result = []\n    \n    # Iterate through all numbers from a to b inclusive\n    for num in range(a + 1000000 if a > -99999 else -a + b - a + ...): \n        # Check if the number is even\n        if num % 2 == 0:\n            result.append(str(num))\n    \n    return sorted(result)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "generate_integers"}
