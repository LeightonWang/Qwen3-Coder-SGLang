{"task_id": "HumanEval/0", "completion": "<think>\n\n</think>\n\n```python\nfrom typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    if not numbers:\n        return False\n    \n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    \n    return False\n```", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n", "entry_point": "has_close_elements"}
{"task_id": "HumanEval/1", "completion": "<think>\n\n</think>\n\n```python\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    i = 0\n    n = len(paren_string)\n    \n    while i < n:\n        j = i + 1\n        while j < n and paren_string[j] == '(':\n            j += 1\n        \n        if j - i == 0:\n            result.append('')  # Skip empty string, which is not a valid group\n            \n        # Extract the substring between current '(' and closing ')'\n        group = paren_string[i:j]\n        \n        # Remove spaces from the string (though input is guaranteed to have no spaces)\n        result.append(group)\n        \n        i = j + 1\n    \n    return result\n```", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n", "entry_point": "separate_paren_groups"}
{"task_id": "HumanEval/2", "completion": "<think>\n\n</think>\n\n```python\ndef truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    \n    >>> truncate_number(3.5)\n    0.5\"\"\"\n    return number - round(number)\n```", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n", "entry_point": "truncate_number"}
{"task_id": "HumanEval/3", "completion": "<think>\n\n</think>\n\n```python\nfrom typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n    balance = 0\n    for op in operations:\n        if op < 0:\n            return True\n        balance += op\n    return False\n```", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n", "entry_point": "below_zero"}
{"task_id": "HumanEval/4", "completion": "<think>\n\n</think>\n\n```python\nfrom typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\"\"\"\n\n    # Calculate the mean of the numbers\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate the absolute differences from the mean and sum them up\n    total_abs_diff = sum(abs(x - mean) for x in numbers)\n    \n    # Divide by the number of elements to get MAD\n    return total_abs_diff / len(numbers)\n```", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6\n\n", "entry_point": "mean_absolute_deviation"}
{"task_id": "HumanEval/5", "completion": "<think>\n\n</think>\n\n```python\nfrom typing import List\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    result = []\n    for i in range(len(numbers)):\n        if i == 0:\n            result.append(numbers[i])\n        else:\n            result.append(delimeter)\n            result.append(numbers[i])\n    return result\n```", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n", "entry_point": "intersperse"}
{"task_id": "HumanEval/6", "completion": "<think>\n\n</think>\n\n```python\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    stack = []\n    result = []\n    \n    for char in paren_string:\n        if char == '(':\n            stack.append(char)\n        else:\n            if stack:\n                result.append(len(stack))\n                stack.pop()\n    \n    return result\n```", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n", "entry_point": "parse_nested_parens"}
{"task_id": "HumanEval/7", "completion": "<think>\n\n</think>\n\n```python\nfrom typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for those that contain the given substring.\"\"\"\n    return [s for s in strings if substring in s]\n```", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n", "entry_point": "filter_by_substring"}
{"task_id": "HumanEval/8", "completion": "<think>\n\n</think>\n\n```python\nfrom typing import List, Tuple\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    \n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n    if not numbers:\n        return (0, 1)\n\n    total_sum = sum(numbers)\n    total_product = multiply(numbers)\n\n    return (total_sum, total_product)\n```\n\n```python\ndef multiply(numbers: List[int]) -> int:\n```", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n", "entry_point": "sum_product"}
{"task_id": "HumanEval/9", "completion": "<think>\n\n</think>\n\n```python\nfrom typing import List, Tuple\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    result = []\n    for i in range(len(numbers)):\n        result.append(max(numbers[i], numbers[i - 1] if i > 0 else numbers[0]))\n    return result\n```", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n", "entry_point": "rolling_max"}
{"task_id": "HumanEval/10", "completion": "<think>\n\n</think>\n\n```python\ndef is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \n    >>> make_palindrome('')\n    ''\n    \n    >>> make_palindrome('cat')\n    'catac'\n    \n    >>> make_palindrome('cata')\n    'catac'\"\n    \n     \"\"\"\n     # Find longest palindromic prefix\n     n = len(string)\n     for i in range(n, 0, -1):\n         if is_palindrome(string[:i]):\n             break\n    \n     # If no prefix found (all characters are not palindromes), return original\n     if i == 1:\n         return ''.join([string])\n     \n     # Construct result by taking prefix + reverse of suffix part\n     suffix_part = string[i:]\n     reversed_prefix = ''.join(reversed(string[:i]))\n     \n     return reversed_prefix + suffix_part + ''.join([string[:i]])\n```", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n", "entry_point": "make_palindrome"}
{"task_id": "HumanEval/11", "completion": "<think>\n\n</think>\n\n```python\nfrom typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\"Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\"\"\"\n    xor_result = []\n    for i in range(len(a)):\n        xor_result.append(str(int(a[i]) ^ int(b[i])))\n    return ''.join(xor_result)\n```", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n", "entry_point": "string_xor"}
{"task_id": "HumanEval/12", "completion": "<think>\n\n</think>\n\n```python\nfrom typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    \n    max_len = len(strings[0])\n    result = strings[0]\n    \n    for s in strings[1:]:\n        if len(s) > max_len:\n            max_len = len(s)\n            result = s\n    \n    return result\n```", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n", "entry_point": "longest"}
{"task_id": "HumanEval/13", "completion": "<think>\n\n</think>\n\n```python\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b \"\"\"\n    while b != 0:\n        a, b = b, a % b\n    return a\n```", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n", "entry_point": "greatest_common_divisor"}
{"task_id": "HumanEval/14", "completion": "<think>\n\n</think>\n\n```python\nfrom typing import List\n\ndef all_prefixes(string: str) -> List[str]:\n    return [s for s in string]\n```", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n", "entry_point": "all_prefixes"}
{"task_id": "HumanEval/15", "completion": "<think>\n\n</think>\n\n```python\ndef string_sequence(n: int) -> str:\n    \"\"\" Return a string containing space-delimited numbers starting from 0 up to n inclusive.\"\"\"\n    return \" \".join(str(i) for i in range(n + 1))\n```", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n", "entry_point": "string_sequence"}
{"task_id": "HumanEval/16", "completion": "<think>\n\n</think>\n\n```python\ndef count_distinct_characters(string: str) -> int:\n    return len(set(string))\n```", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n", "entry_point": "count_distinct_characters"}
{"task_id": "HumanEval/17", "completion": "<think>\n\n</think>\n\n```python\nfrom typing import List\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\"Input is a string representing musical notes in a special ASCII format.\n    Output is a list of integers corresponding to how many beats each note lasts.\n    \n    Legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n    \n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4]\"\"\"\n    \n    return [4 if c == 'o' else (2 if c == 'o|\" else (1 if c == \".|\" else None) for c in music_string)]\n```", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n", "entry_point": "parse_music"}
{"task_id": "HumanEval/18", "completion": "<think>\n\n</think>\n\n```python\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    \n    Args:\n        string: The original string to search in.\n        substring: The substring to count.\n\n    Returns:\n        The number of times the substring appears in the original string, counting overlaps.\n\n    Examples:\n        >>> how_many_times('', 'a')\n        0\n        >>> how_many_times('aaa', 'a')\n        3\n        >>> how_many_times('aaaa', 'aa')\n        3\n    \"\"\"\n    if not string or not substring:\n        return 0\n    \n    count = 0\n    i = 0\n    \n    while i < len(string):\n        j = i + len(substring)\n        \n        # Check if the current window matches the pattern and is within bounds.\n        \n            # If it does, increment count and move forward by one character (to account for overlapping)\n            if j <= len(string):\n                if string[i:j] == substring:\n                    count += 1\n                    i += len(substring) - (i + len(substring)) + (len(substring) - i)\n                else:\n                    i += 1\n                    \n            else:\n                break\n                \n    \n    return count\n```", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n", "entry_point": "how_many_times"}
{"task_id": "HumanEval/19", "completion": "<think>\n\n</think>\n\n```python\nfrom typing import List\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\"Input is a space-delimited string of numbers from 'zero' to 'nine'.\n    Return the string with numbers sorted from smallest to largest.\n    \n    >>> sort_numbers('three one five')\n    'one three five'\"\n    \"\"\"\n    return \" \".join(sorted(numbers.split()))\n```", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n", "entry_point": "sort_numbers"}
{"task_id": "HumanEval/20", "completion": "<think>\n\n</think>\n\n```python\nfrom typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each other and return them in order (smaller number, larger number).\"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must have at least two elements.\")\n    \n    # Find the closest pair of elements using binary search\n    left = 0\n    right = len(numbers) - 1\n    \n    while left < right:\n        mid = (left + right) // 2\n        \n        if numbers[mid] > numbers[right]:\n            right = mid\n        else:\n            left = mid + 1\n            \n    # Now we have the index where the smallest element is located\n    min_val_index = left\n    \n    # Find the next element that is as close as possible to min_val_index\n    for i in range(min_val_index + 1, len(numbers)):\n        if abs(numbers[i] - numbers[min_val_index]) < abs(numbers[i] - numbers[left]):\n            min_val_index = i\n            \n    \n    return (numbers[min_val_index], numbers[left])\n```", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n", "entry_point": "find_closest_elements"}
{"task_id": "HumanEval/21", "completion": "<think>\n\n</think>\n\n```python\nfrom typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    \n    Parameters:\n        numbers: A list of floats\n    \n    Returns:\n        A list of floats where each element is scaled to be between 0 and 1\n    \n    Example:\n        >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n        [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    min_val = min(numbers)\n    max_val = max(numbers)\n    \n    scaled_numbers = [(num / max_val) if num != min_val else (min_val / max_val) for num in numbers]\n    \n    return scaled_numbers\n```", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n", "entry_point": "rescale_to_unit"}
{"task_id": "HumanEval/22", "completion": "<think>\n\n</think>\n\n```python\nfrom typing import List, Any\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    return [x for x in values if isinstance(x, int)]\n```", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n", "entry_point": "filter_integers"}
{"task_id": "HumanEval/23", "completion": "<think>\n\n</think>\n\n```python\ndef strlen(string: str) -> int:\n    \"\"\" Return length of given string \"\"\"\n    return len(string)\n```", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n", "entry_point": "strlen"}
{"task_id": "HumanEval/24", "completion": "<think>\n\n</think>\n\n```python\ndef largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n \"\"\"\n    return n - 1\n```", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n", "entry_point": "largest_divisor"}
{"task_id": "HumanEval/25", "completion": "<think>\n\n</think>\n\n```python\nfrom typing import List\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    \n    >>> factorize(8)\n    [2, 2, 2]\n    \n    >>> factorize(25)\n    [5, 5]\n    \n    >>> factorize(70)\n    [2, 5, 7]\n    \n    \"\"\"\n    \n     # Initialize a list for result\n     result = []\n     i = 2\n    \n     while n > 1:\n         if n % i == 0:\n             result.append(i * i) # Store squared as it's repeated multiple times\n             while n % i == 0:\n                 n //= i\n         else:\n             i += 1\n        \n        return result\n```", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n", "entry_point": "factorize"}
{"task_id": "HumanEval/26", "completion": "<think>\n\n</think>\n\n```python\nfrom typing import List\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    return list(set(numbers))\n```", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n", "entry_point": "remove_duplicates"}
{"task_id": "HumanEval/27", "completion": "<think>\n\n</think>\n\n```python\ndef flip_case(string: str) -> str:\n    return string.swapcase()\n```", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n", "entry_point": "flip_case"}
{"task_id": "HumanEval/28", "completion": "<think>\n\n</think>\n\n```python\nfrom typing import List\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\"Concatenate list of strings into a single string.\"\"\"\n    return ''.join(strings)\n```", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n", "entry_point": "concatenate"}
{"task_id": "HumanEval/29", "completion": "<think>\n\n</think>\n\n```python\nfrom typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    return [s for s in strings if s.startswith(prefix)]\n```", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n", "entry_point": "filter_by_prefix"}
{"task_id": "HumanEval/30", "completion": "<think>\n\n</think>\n\n```python\ndef get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\"\"\"\n    return [num for num in l if num > 0]\n```", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n", "entry_point": "get_positive"}
{"task_id": "HumanEval/31", "completion": "<think>\n\n</think>\n\n```python\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n```", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n", "entry_point": "is_prime"}
{"task_id": "HumanEval/32", "completion": "<think>\n\n</think>\n\n```python\nimport math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    \n        >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    \n        >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3)\n        \"\"\"\n    \n    # Ensure the number of coefficients is even and non-zero coefficient is the largest one\n     n = len(xs)\n     if n % 2 != 0:\n         raise ValueError(\"Number of coefficients must be even\")\n     \n     max_coeff = max(abs(coeff) for coeff in sorted(xs))\n     idx_max = [i for i in range(n // abs(max_coeff)) if abs(coeffs[i]) == max_coeff][0]\n     \n     # Find root using Newton-Raphson method or other suitable method\n     root = [coeff / (-xs[idx_max]) for idx in range(len(xs))]\n     \n     return round(root[-1], int(math.floor(4))) \n```", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n", "entry_point": "find_zero"}
{"task_id": "HumanEval/33", "completion": "<think>\n\n</think>\n\n```python\ndef sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\"\"\"\n    result = []\n    for i in range(len(l)):\n        if i % 3 != 0:\n            result.append(l[i])\n        else:\n            # Extract value from original list and sort it\n            value = sorted(l[i // 3])\n            result.append(value)\n    return result\n```", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n", "entry_point": "sort_third"}
{"task_id": "HumanEval/34", "completion": "<think>\n\n</think>\n\n```python\ndef unique(l: list):\n    \"\"\"Return sorted unique elements in a list.\"\"\"\n    return sorted(set(l))\n```", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n", "entry_point": "unique"}
{"task_id": "HumanEval/35", "completion": "<think>\n\n</think>\n\n```python\ndef max_element(l: list):\n    \"\"\"Return maximum element in the list.\"\"\"\n    return max(l)\n```", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n", "entry_point": "max_element"}
{"task_id": "HumanEval/36", "completion": "<think>\n\n</think>\n\n```python\ndef fizz_buzz(n: int):\n    count = 0\n    for i in range(1, n + 1):\n        if i % 11 == 0 or i % 13 == 0:\n            count += 1\n    return count\n```", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n", "entry_point": "fizz_buzz"}
{"task_id": "HumanEval/37", "completion": "<think>\n\n</think>\n\n```python\ndef sort_even(l: list):\n    l_new = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            l_new.append(l[i])\n        else:\n            l_new.append(sorted(l[i]))\n    return l_new\n```", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n", "entry_point": "sort_even"}
{"task_id": "HumanEval/38", "completion": "<think>\n\n</think>\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    \n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    \n    # reverse the order of the groups to get the correct sequence\n    return ''.join(groups[::-1])", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n", "entry_point": "decode_cyclic"}
{"task_id": "HumanEval/39", "completion": "<think>\n\n</think>\n\n```python\ndef prime_fib(n: int):\n    \"\"\"prime_fib returns n-th number that is a Fibonacci number and it's also prime.\"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    fib_numbers = [f for f in (0, 1) if is_prime(f)]\n    return fib_numbers[n-1]\n```", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n", "entry_point": "prime_fib"}
{"task_id": "HumanEval/40", "completion": "<think>\n\n</think>\n\n```python\ndef triples_sum_to_zero(l: list):\n    # Create a set of the list to remove duplicates\n    unique_elements = set(l)\n    \n    # Check for all possible triplets in the unique elements\n    for i in range(len(unique_elements) - 2):\n        for j in range(i + 1, len(unique_elements) - 1):\n            for k in range(j + 1, len(unique_elements)):\n                if (unique_elements[i] + unique_elements[j] + unique_elements[k]) == 0:\n                    return True\n    \n    return False\n```", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n", "entry_point": "triples_sum_to_zero"}
{"task_id": "HumanEval/41", "completion": "<think>\n\n</think>\n\n```python\ndef car_race_collision(n: int):\n    return n * (n - 1) // 2\n```", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n", "entry_point": "car_race_collision"}
{"task_id": "HumanEval/42", "completion": "<think>\n\n</think>\n\n```python\ndef incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\"\"\"\n    return [x + 1 for x in l]\n```", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n", "entry_point": "incr_list"}
{"task_id": "HumanEval/43", "completion": "<think>\n\n</think>\n\n```python\ndef pairs_sum_to_zero(l):\n    return False\n```", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n", "entry_point": "pairs_sum_to_zero"}
{"task_id": "HumanEval/44", "completion": "<think>\n\n</think>\n\n```python\ndef change_base(x: int, base: int):\n    if x == 0:\n        return \"0\"\n    digits = []\n    while x > 0:\n        digits.append(x % base)\n        x //= base\n    return ''.join(str(d) for d in reversed(digits))\n```", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n", "entry_point": "change_base"}
{"task_id": "HumanEval/45", "completion": "<think>\n\n</think>\n\n```python\ndef triangle_area(a, h):\n    return 0.5 * a * h\n```", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n", "entry_point": "triangle_area"}
{"task_id": "HumanEval/46", "completion": "<think>\n\n</think>\n\n```python\ndef fib4(n: int):\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n    if n == 0 or n == 1:\n        return 0\n    a, b, c = 0, 0, fib4(n - 2)\n    for _ in range(3):\n        d = a + b + c + fib4(n - 3)\n        a, b, c = b, c, d\n    return d\n```", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n", "entry_point": "fib4"}
{"task_id": "HumanEval/47", "completion": "<think>\n\n</think>\n\n```python\ndef median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    l.sort()\n    n = len(l)\n    \n    if n % 2 == 1:\n        return l[n // 2]\n    \n    return (l[n // 2 - i] + l[n // i]) / (n + i) for i in range(1 << n)\n```", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n", "entry_point": "median"}
{"task_id": "HumanEval/48", "completion": "<think>\n\n</think>\n\n```python\ndef is_palindrome(text: str):\n    return text == text[::-1]\n```", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n", "entry_point": "is_palindrome"}
{"task_id": "HumanEval/49", "completion": "<think>\n\n</think>\n\n```python\ndef modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)\n```", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n", "entry_point": "modp"}
{"task_id": "HumanEval/50", "completion": "<think>\n\n</think>\n\n```python\ndef encode_shift(s: str):\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n```", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n", "entry_point": "decode_shift"}
{"task_id": "HumanEval/51", "completion": "<think>\n\n</think>\n\n```python\ndef remove_vowels(text):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    return ''.join([char for char in text if char not in vowels])\n```", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n", "entry_point": "remove_vowels"}
{"task_id": "HumanEval/52", "completion": "<think>\n\n</think>\n\n```python\ndef below_threshold(l: list, t: int) -> bool:\n    return all(num < t for num in l)\n```", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n", "entry_point": "below_threshold"}
{"task_id": "HumanEval/53", "completion": "<think>\n\n</think>\n\n```python\ndef add(x: int, y: int):\n    \"\"\"Add two numbers x and y\"\"\"\n    return x + y\n```", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n", "entry_point": "add"}
{"task_id": "HumanEval/54", "completion": "<think>\n\n</think>\n\n```python\ndef same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)\n```", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n", "entry_point": "same_chars"}
{"task_id": "HumanEval/55", "completion": "<think>\n\n</think>\n\n```python\ndef fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b\n```", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n", "entry_point": "fib"}
{"task_id": "HumanEval/56", "completion": "<think>\n\n</think>\n\n```python\ndef correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n    \n```", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n", "entry_point": "correct_bracketing"}
{"task_id": "HumanEval/57", "completion": "<think>\n\n</think>\n\n```python\ndef monotonic(l: list):\n    \"\"\"Return True if the list elements are monotonically increasing or decreasing.\"\"\"\n    for i in range(1, len(l)):\n        if l[i] < l[i - 1]:\n            return False\n    return True\n```", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n", "entry_point": "monotonic"}
{"task_id": "HumanEval/58", "completion": "<think>\n\n</think>\n\n```python\ndef common(l1: list, l2: list):\n    return sorted(set(l1) & set(l2))\n```", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n", "entry_point": "common"}
{"task_id": "HumanEval/59", "completion": "<think>\n\n</think>\n\n```python\ndef largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    # Find the largest prime factor\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            while n % i == 0:\n                n //= i\n            # Update the maximum factor if needed\n            max_factor = max(max_factor, i)\n        else:\n            # If no factors found, then it's a prime itself (but according to problem statement, this won't happen)\n            pass\n        i += 1\n    \n    return max_factor if max_factor != 1 else None\n```", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n", "entry_point": "largest_prime_factor"}
{"task_id": "HumanEval/60", "completion": "<think>\n\n</think>\n\n```python\ndef sum_to_n(n: int):\n    return n * (n + 1) // 2\n```", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n", "entry_point": "sum_to_n"}
{"task_id": "HumanEval/61", "completion": "<think>\n\n</think>\n\n```python\ndef correct_bracketing(brackets: str):\n    balance = 0\n    for char in brackets:\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n        if balance < 0:\n            return False\n    return True\n```", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n", "entry_point": "correct_bracketing"}
{"task_id": "HumanEval/62", "completion": "<think>\n\n</think>\n\n```python\ndef derivative(xs: list):\n    return [xs[i] * i for i in range(len(xs)) if i != 0]\n```", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n", "entry_point": "derivative"}
{"task_id": "HumanEval/63", "completion": "<think>\n\n</think>\n\n```python\ndef fibfib(n: int):\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n    elif n == 0 or n == 1:\n        return 0\n    else:\n        a, b, c = 0, 0, 1\n        for _ in range(3, n + 1):\n            new_val = a + b + c\n            a = b\n            b = c\n            c = new_val\n        return c\r\n```", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n", "entry_point": "fibfib"}
{"task_id": "HumanEval/64", "completion": "<think>\n\n</think>\n\n```python\ndef vowels_count(s):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n    return count\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "vowels_count"}
{"task_id": "HumanEval/65", "completion": "<think>\n\n</think>\n\n```python\ndef circular_shift(x, shift):\n    if shift > len(str(x)):\n        return str(int(x))[::-1]\n    return str(int(x))[shift:] + str(int(x)[:shift]]\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "circular_shift"}
{"task_id": "HumanEval/66", "completion": "<think>\n\n</think>\n\n```python\ndef digitSum(s):\n    return sum(ord(c) for c in s if c.isdigit())\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n", "entry_point": "digitSum"}
{"task_id": "HumanEval/67", "completion": "<think>\n\n</think>\n\n```python\ndef fruit_distribution(s, n):\n    oranges = int(s.split()[1])\n    apples = int(s.split()[0])\n    total_fruits = n\n    mango_fruits = total_fruits - apples - oranges\n    return mango_fruits\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n", "entry_point": "fruit_distribution"}
{"task_id": "HumanEval/68", "completion": "<think>\n\n</think>\n\n```python\ndef pluck(arr):\n    if not arr:\n        return []\n    smallest_even = None\n    min_index = float('inf')\n    \n    for i, value in enumerate(arr):\n        if value % 2 == 0:\n            if smallest_even is None or value < smallest_even or (value == smallest_even and i < min_index):\n                smallest_even = value\n                min_index = i\n    \n    return [smallest_even, min_index] if smallest_even is not None else []\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n", "entry_point": "pluck"}
{"task_id": "HumanEval/69", "completion": "<think>\n\n</think>\n\n```python\ndef search(lst):\n    from collections import Counter\n    \n    counts = Counter(lst)\n    \n    for num in counts:\n        if counts[num] > num:\n            return num\n    return -1\n```", "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n", "entry_point": "search"}
{"task_id": "HumanEval/70", "completion": "<think>\n\n</think>\n\n```python\ndef strange_sort_list(lst):\n    return sorted(lst, key=lambda x: (x, lst.index(x)))[::-1]\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "strange_sort_list"}
{"task_id": "HumanEval/71", "completion": "<think>\n\n</think>\n\n```python\ndef triangle_area(a, b, c):\n    # Check if the three sides form a valid triangle\n    if a + b > c and a + c > b and b + c > a:\n        # Calculate area using Heron's formula\n        semiperimeter = (a + b + c) / 2\n        area = semiperimeter * (semiperimeter - a) * (semiperimeter - b) * (semiperimeter - c)\n        return round(area, 2)\n    else:\n        return -1\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n", "entry_point": "triangle_area"}
{"task_id": "HumanEval/72", "completion": "<think>\n\n</think>\n\n```python\ndef will_it_fly(q, w):\n    if q == q[::-1] and sum(q) <= w:\n        return True\n    else:\n        return False\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n", "entry_point": "will_it_fly"}
{"task_id": "HumanEval/73", "completion": "<think>\n\n</think>\n\n```python\ndef smallest_change(arr):\n    n = len(arr)\n    i = 0\n    j = n - 1\n    \n    while i < j:\n        if arr[i] != arr[j]:\n            # Change the element at i to match the element at j or vice versa\n            # Only one change is needed for each pair\n            return n - (i + j)\n        i += 1\n        j -= 1\n    \n    return n\r\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n", "entry_point": "smallest_change"}
{"task_id": "HumanEval/74", "completion": "<think>\n\n</think>\n\n```python\ndef total_match(lst1, lst2):\n    if len(lst1) == len(lst2):\n        return lst1\n    else:\n        return [item for item in lst2 if len(item) < len(lst1)]\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n", "entry_point": "total_match"}
{"task_id": "HumanEval/75", "completion": "<think>\n\n</think>\n\n```python\ndef is_multiply_prime(a):\n    \"\"\"Returns True if the given number is the product of three prime numbers and False otherwise.\"\"\"\n    if a < 100:\n        return False\n    for i in range(2, int(a**0.5) + 1):\n        if a % i == 0:\n            return False\n    for i in range(3, int(a**0.5) + 1):\n        if a % i == 0:\n            return False\n    return True\n```", "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n", "entry_point": "is_multiply_prime"}
{"task_id": "HumanEval/76", "completion": "<think>\n\n</think>\n\n```python\ndef is_simple_power(x, n):\n    return int(n ** (x ** 0.5)) == x\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "is_simple_power"}
{"task_id": "HumanEval/77", "completion": "<think>\n\n</think>\n\n```python\ndef iscube(a):\n    return a ** (1/3) == int(a ** (1/3))\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n", "entry_point": "iscube"}
{"task_id": "HumanEval/78", "completion": "<think>\n\n</think>\n\n```python\ndef hex_key(num):\n    \"\"\"You have been tasked to write a function that receives \n    a hexadecimal number as a string and counts the number of hexadecimal \n    digits that are primes (prime number, or a prime, is a natural number \n    greater than 1 that is not a product of two smaller natural numbers).\n    Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    Prime numbers are 2, 3, 5,\n    \nSo you have to determine a number of the following digits:  \n2 (decimal), B (decimal), D (decimal).\nNote: you may assume the input is always correct or empty string,\nand symbols A,B,C,D,E,F are always uppercase.\n\nExamples:\nFor num = \"AB\" the output should be **1**.\nFor num = \"1077E\" the output should be **2**.\nFor num = \"ABED1A33\" the output should be **4**.\nFor num = \"123456789ABCDEF0\" the output should be **6**.\nFor num = \"2020\" the output should be **2**.\"\"\"\n\n# Convert input to lowercase for case-insensitive checking\nnum_lower = num.lower()\n\n# List of valid prime hexadecimal digits\nprimes_hex_digits = {'A': 'A', 'B': 'B', 'D': 'D'}\n\ncount_primes_hex_digits = sum(1 for digit in num_lower if digit in primes_hex_digits)\n\nreturn count_primes_hex_digits\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n", "entry_point": "hex_key"}
{"task_id": "HumanEval/79", "completion": "<think>\n\n</think>\n\n```python\ndef decimal_to_binary(decimal):\n    return \"db\" + bin(decimal)[2:] + \"db\"\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "decimal_to_binary"}
{"task_id": "HumanEval/80", "completion": "<think>\n\n</think>\n\n```python\ndef is_happy(s):\n    from collections import defaultdict\n\n    # Check if the length is at least 3\n    if len(s) < 3:\n        return False\n    \n    # Track the characters in a set to check for duplicates\n    seen = set()\n    \n    # Process each character in the string\n    for char in s:\n        if char in seen:\n            return False\n        \n        seen.add(char)\n        \n        # If we've processed 3 characters, check for duplicates again (as next step)\n        if len(seen) >= 3:\n            break\n    \n    return True\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n", "entry_point": "is_happy"}
{"task_id": "HumanEval/81", "completion": "<think>\n\n</think>\n\n```python\ndef numerical_letter_grade(grades):\n    letter_grades = []\n    for grade in grades:\n        if grade >= 4.0:\n            letter_grades.append('A+')\n        elif grade >= 3.7:\n            letter_grades.append('A')\n        elif grade >= 3.3:\n            letter_grades.append('A-')\n        elif grade >= 3.0:\n            letter_grades.append('B+')\n        elif grade >= 2.7:\n            letter_grades.append('B')\n        elif grade >= 2.0:\n            letter_grades.append('C+')\n        elif grade >= 1.7:\n            letter_grades.append('C')\n        elif grade >= 1.0:\n            letter_grades.append('D+')\n        else: \n            if grade > 0 and (grade <= -1):\n                pass\n    return ''.join(letter_grades)\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "numerical_letter_grade"}
{"task_id": "HumanEval/82", "completion": "<think>\n\n</think>\n\n```python\ndef prime_length(string):\n    \"\"\"Write a function that takes a string and returns True if the string length is a prime number or False otherwise.\"\"\"\n    return len(string) in [2, 3, 5, 7, 11, 13]\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n", "entry_point": "prime_length"}
{"task_id": "HumanEval/83", "completion": "<think>\n\n</think>\n\n```python\ndef starts_one_ends(n):\n    return (n - 1) // 10 + (n - 1) % 10 + 2\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "starts_one_ends"}
{"task_id": "HumanEval/84", "completion": "<think>\n\n</think>\n\n```python\ndef solve(N):\n    \"\"\"Given a positive integer N, return the total sum of its digits in binary.\n    \n    Example\n        For N = 1000, the sum of digits will be 1 the output should be \"1\".\n        For N = 150, the sum of digits will be 6 the output should be \"110\".\n        For N = 147, the sum of digits will be 12 the output should be \"1100\".\n    \n    Variables:\n        @N integer\n             Constraints: 0 \u2264 N \u2264 10000.\n    Output:\n         a string of binary number\"\"\"\n    return bin(N).count('1')\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n", "entry_point": "solve"}
{"task_id": "HumanEval/85", "completion": "<think>\n\n</think>\n\n```python\ndef add(lst):\n    total = 0\n    for i, num in enumerate(lst):\n        if i % 2 == 1 and num % 2 == 0:\n            total += num\n    return total\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n", "entry_point": "add"}
{"task_id": "HumanEval/86", "completion": "<think>\n\n</think>\n\n```python\ndef anti_shuffle(s):\n    # Split the string into words and remove any empty strings\n    words = [word for word in s.split() if word.strip()]\n    \n    # Sort the words based on their ASCII values\n    sorted_words = sorted(words)\n    \n    # Join the sorted words with spaces and return as a string\n    return ' '.join(sorted_words)\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "anti_shuffle"}
{"task_id": "HumanEval/87", "completion": "<think>\n\n</think>\n\n```python\ndef get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n        get_row([\n          [1,2,3,4,5],\n          [1],\n          [1]\n        ], 3) == [(0,), (0,), (0,)]\n\n        get_row([[], [1], [1]], 3) == [(2,), (0,), (0)]\n        \n        get_row([[]], 5) == []\n    \n    \"\"\"\n    \n# Find all indices where the value equals 'x' in the list\n    \ncoordinates = []\nfor i in range(len(lst)):\n     if lst[i][x] != None:\n         coordinates.append((i * len(lst[0]), i))\n        \n# Sort by rows ascending and then columns descending\n    \ncoordinates.sort(key=lambda coord: (-coord[0], -coord[1]))\nreturn coordinates\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "get_row"}
{"task_id": "HumanEval/88", "completion": "<think>\n\n</think>\n\n```python\ndef sort_array(array):\n    sum_first_last = array[0] + array[-1]\n    if sum_first_last % 2 == 1:\n        return sorted(array)\n    else:\n        return sorted(array, reverse=True)\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n", "entry_point": "sort_array"}
{"task_id": "HumanEval/89", "completion": "<think>\n\n</think>\n\n```python\ndef encrypt(s):\n    result = []\n    for char in s:\n        # Convert to lowercase for case insensitivity\n        lower_char = char.lower()\n        # Calculate the new character based on rotation\n        if lower_char == 'a':\n            result.append('c')\n        elif lower_char == 'b':\n            result.append('d')\n        elif lower_char == 'c':\n            result.append('e')\n        elif lower_char == 'd':\n            result.append('f')\n        elif lower_char == 'e':\n            result.append('g')\n        elif lower_char == 'f':\n            result.append('h')\n        elif lower_char == 'g':\n            result.append('i')\n    return ''.join(result)\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "encrypt"}
{"task_id": "HumanEval/90", "completion": "<think>\n\n</think>\n\n```python\ndef next_smallest(lst):\n    if not lst:\n        return None\n    sorted_lst = sorted(lst)\n    return sorted_lst[1] if len(sorted_lst) > 1 else None\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "next_smallest"}
{"task_id": "HumanEval/91", "completion": "<think>\n\n</think>\n\n```python\ndef is_bored(S):\n    \"\"\"\n    You'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is a sentence that starts with the word \"I\".\n    Sentences are delimited by '.', '?' or '!'.\n   \n    For example:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n    \n# Split the string into sentences using ., ?, or ! as delimiters\nsentences = S.split('.')\ncount = 0\n    \nfor sentence in sentences:\n    \n# Check if the current sentence starts with \"I\"\nif sentence.startswith(\"I\"):\n    \n# Add to count if it's a valid sentence (i.e., ends with a punctuation)\nif len(sentence) > 0 and (sentence.endswith('.') or sentence.endswith('?') or sentence.endswith('!')):\n        \ncount += 1\n    \nreturn count\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "is_bored"}
{"task_id": "HumanEval/92", "completion": "<think>\n\n</think>\n\n```python\ndef any_int(x, y, z):\n    return (x + y == z) or (x + z == y) or (y + z == x)\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n", "entry_point": "any_int"}
{"task_id": "HumanEval/93", "completion": "<think>\n\n</think>\n\n```python\ndef encode(message):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    result = []\n    for char in message:\n        if char.isalpha():\n            if char.lower() in vowels:\n                result.append(char.lower() + str((ord(char.lower()) + 1) % 26))\n            else:\n                result.append(char.swapcase())\n        else:\n            result.append(char)\n    return ''.join(result)\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "encode"}
{"task_id": "HumanEval/94", "completion": "<think>\n\n</think>\n\n```python\ndef skjkasdkd(lst):\n    max_prime = 0\n    for num in lst:\n        if is_prime(num):\n            if num > max_prime:\n                max_prime = num\n    return sum(int(digit) for digit in str(max_prime))\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n", "entry_point": "skjkasdkd"}
{"task_id": "HumanEval/95", "completion": "<think>\n\n</think>\n\n```python\ndef check_dict_case(dict):\n    \"\"\"Return True if all keys are in lower case or all are in upper case.\"\"\"\n    if not dict:\n        return False\n    \n    for key, value in dict.items():\n        if not isinstance(key, str):\n            return False\n    \n    # All keys are strings, check their case\n    for key, value in dict.items():\n        if key.islower() != value.lower().islower():\n            return False\n    \n    return True\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n", "entry_point": "check_dict_case"}
{"task_id": "HumanEval/96", "completion": "<think>\n\n</think>\n\n```python\ndef count_up_to(n):\n    \"\"\"Implement a function that takes an non-negative integer and returns an array of the first n integers that are prime numbers and less than n.\"\"\"\n    primes = []\n    for num in range(2, n):\n        is_prime = True\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(num)\n    return primes\n```", "test": "def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n", "entry_point": "count_up_to"}
{"task_id": "HumanEval/97", "completion": "<think>\n\n</think>\n\n```python\ndef multiply(a, b):\n    \"\"\"Complete the function that takes two integers and returns \n    the product of their unit digits.\n    Assume the input is always valid.\"\"\"\n    return (a % 10) * (b % 10)\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n", "entry_point": "multiply"}
{"task_id": "HumanEval/98", "completion": "<think>\n\n</think>\n\n```python\ndef count_upper(s):\n    return sum(1 for i in range(len(s)) if s[i].isupper() and (i % 2 == 0))\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "count_upper"}
{"task_id": "HumanEval/99", "completion": "<think>\n\n</think>\n\n```python\ndef closest_integer(value):\n    \"\"\"\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples:\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n        Rounding away from zero means that if the given number is equidistant\n        from two integers, the one you should return is the farthest from zero.\n        For example: closest_integer(\"14.5\") should return 15 and closest_integer(\"-14.5\") should return -15.\n    \n    Args:\n        value (str): A string representing a number.\n\n     Returns:\n         int: The closest integer to the input value.\n     \"\"\"\n    \n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n", "entry_point": "closest_integer"}
{"task_id": "HumanEval/100", "completion": "<think>\n\n</think>\n\n```python\ndef make_a_pile(n):\n    result = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            result.append(i)\n        else:\n            result.append(i + 2)\n    return result\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "make_a_pile"}
{"task_id": "HumanEval/101", "completion": "<think>\n\n</think>\n\n```python\ndef words_string(s):\n    return s.split()\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n", "entry_point": "words_string"}
{"task_id": "HumanEval/102", "completion": "<think>\n\n</think>\n\n```python\ndef choose_num(x, y):\n    if x > y:\n        x, y = y, x\n    if (x % 2 == 0) or (y % 2 == 0):\n        return max(x, y)\n    else:\n        return -1\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n", "entry_point": "choose_num"}
{"task_id": "HumanEval/103", "completion": "<think>\n\n</think>\n\n```python\ndef rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    \"\"\"\n    \n    if n > m:\n        return -1\n    \n    total = sum(range(n, m + 1))\n    \n    avg = round(total / (m - n + 2))\n    \n    return f\"0b{bin(avg)[2:]}\"\n\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n", "entry_point": "rounded_avg"}
{"task_id": "HumanEval/104", "completion": "<think>\n\n</think>\n\n```python\ndef unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\"\"\"\n    return [num for num in x if all(c != '0' and int(c) % 2 != 0 for c in str(num))]\n\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "unique_digits"}
{"task_id": "HumanEval/105", "completion": "<think>\n\n</think>\n\n```python\ndef by_length(arr):\n    sorted_arr = sorted(arr)\n    reversed_arr = sorted_arr[::-1]\n    result = []\n    for num in reversed_arr:\n        if num >= 1 and num <= 9:\n            result.append([\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"][num - 1])\n    return result\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n", "entry_point": "by_length"}
{"task_id": "HumanEval/106", "completion": "<think>\n\n</think>\n\n```python\ndef f(n):\n    result = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            result.append(i * (i - 1) // 2)\n        else:\n            result.append(sum(range(1, i + 1)))\n    return result\n```", "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n", "entry_point": "f"}
{"task_id": "HumanEval/107", "completion": "<think>\n\n</think>\n\n```python\ndef even_odd_palindrome(n):\n    count_even = 0\n    count_odd = 0\n    \n    for i in range(1, n + 1):\n        if str(i) == str(i)[::-1]:\n            if i % 2 == 0:\n                count_even += 1\n            else:\n                count_odd += 1\n    \n    return (count_even, count_odd)\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "even_odd_palindrome"}
{"task_id": "HumanEval/108", "completion": "<think>\n\n</think>\n\n```python\ndef count_nums(arr):\n    return sum(1 for num in arr if sum(int(digit) for digit in str(abs(num))) > 0)\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "count_nums"}
{"task_id": "HumanEval/109", "completion": "<think>\n\n</think>\n\n```python\ndef move_one_ball(arr):\n    \"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return True else return False.\n    \n    If the given array is empty then return True.\"\"\"\n\n    # Check if input list is empty or has only one element (since moving once would sort)\n    if len(arr) == 0 or len(arr) == 1:\n        return True\n\n     # Sort list and check if it matches after moving one time (right shift)\n     sorted_arr = sorted(arr)\n     shifted_arr = [sorted_arr[i] for i in range(len(sorted_arr))]\n     shifted_sorted = [shifted_arr[i] for i in range(len(shifted_sorted))]\n\n     # Compare shifted_sorted with original list after moving once (right shift)\n     # Only check for equality since we need a valid sequence after at least one move.\n\n     return shifted_sorted == arr[:len(arr)-1]\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n", "entry_point": "move_one_ball"}
{"task_id": "HumanEval/110", "completion": "<think>\n\n</think>\n\n```python\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    \n    For example:\n        exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    \n    It is assumed that the input lists will be non-empty.\"\"\"\n    \n    # Count how many even numbers are in each list\n    count_even_lst1 = sum(odd(x) for x in lst1)\n    \n    count_even_lst2 = sum(odd(x) for x in lst2)\n    \n     # Check if both lists have at least one even number each\n     if (count_even_lst1 > 0 or count_even_lst2 > 0) and (count_even_lst2 > 0 or count_even_lst1 > 0):\n         return \"YES\"\n     else:\n         return \"NO\"\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n", "entry_point": "exchange"}
{"task_id": "HumanEval/111", "completion": "<think>\n\n</think>\n\n```python\ndef histogram(test):\n    \"\"\"Given a string representing a space separated lowercase letters, return a dictionary\n    of the letter with the most repetition and containing the corresponding count.\n    If several letters have the same occurrence, return all of them.\n    \n    Example:\n    histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n    histogram('a b b a') == {'a': 2, 'b': 2}\n    histogram('a b c a b') == {'a': 2, 'b': 2}\n    histogram('b b b b a') == {'b': 4}\n    histogram('') == {}\n\n    \"\"\"\n    from collections import Counter\n\ndef main():\n   # Count occurrences of each letter in test\n   counts = Counter(test.split())\n   # Get the maximum count and collect all letters with that count\n   max_count = max(counts.values(), default=0)\n   result = {k: v for k, v in counts.items() if v == max_count}\n\nif __name__ == \"__main__\":\n   main()\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n", "entry_point": "histogram"}
{"task_id": "HumanEval/112", "completion": "<think>\n\n</think>\n\n```python\ndef reverse_delete(s, c):\n    result = \"\"\n    for char in s:\n        if char != c:\n            result += char\n    return (result, False)\n```", "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n", "entry_point": "reverse_delete"}
{"task_id": "HumanEval/113", "completion": "<think>\n\n</think>\n\n```python\ndef odd_count(lst):\n    result = []\n    for i, num_str in enumerate(lst):\n        count = sum(1 for c in num_str if int(c) % 2 != 0)\n        result.append(f\"the number of odd elements {count}n the str{n} of the {count}nput.\")\n    return result\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "odd_count"}
{"task_id": "HumanEval/114", "completion": "<think>\n\n</think>\n\n```python\ndef minSubArraySum(nums):\n    if not nums:\n        return 0\n    current_sum = nums[0]\n    min_sum = current_sum\n    for num in nums[1:]:\n        current_sum += num\n        if current_sum < min_sum:\n            min_sum = current_sum\n    return min_sum\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n", "entry_point": "minSubArraySum"}
{"task_id": "HumanEval/115", "completion": "<think>\n\n</think>\n\n```python\ndef max_fill(grid, capacity):\n    import math\n    \n    rows = len(grid)\n    cols = len(grid[0])\n    \n    # Calculate the number of units in each row and column\n    total_units = [sum(row) for row in grid]\n    \n    # Calculate the number of times to lower the bucket for each row\n    result = 0\n    \n    for i in range(rows):\n        if total_units[i] > 0:\n            result += (total_units[i] // capacity) + (1 if total_units[i] % capacity != 0 else 0)\n    \n    return result\n```", "test": "def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n", "entry_point": "max_fill"}
{"task_id": "HumanEval/116", "completion": "<think>\n\n</think>\n\n```python\ndef sort_array(arr):\n    return sorted(arr, key=lambda x: (bin(x).count('1'), x))\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "sort_array"}
{"task_id": "HumanEval/117", "completion": "<think>\n\n</think>\n\n```python\ndef select_words(s, n):\n    \"\"\"Given a string s and a natural number n, you have been tasked to implement \n    a function that returns a list of all words from string s that contain exactly \n    n consonants, in order these words appear in the string s.\n    If the string s is empty then the function should return an empty list.\n    Note: you may assume the input string contains only letters and spaces.\"\"\"\n    \n    result = []\n    \n    # Split the input into words based on spaces\n    words = [word for word in s.split()]\n    \n    # Check if each word has at least 'n' consonants\n    for word in words:\n        if len([char for char in word if char.isalpha() and not char.lower() == 'a']) >= n:\n            result.append(word)\n    \n    return result\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n", "entry_point": "select_words"}
{"task_id": "HumanEval/118", "completion": "<think>\n\n</think>\n\n```python\ndef get_closest_vowel(word):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    i = len(word) - 1\n    j = i - 1\n    \n    while i >= 0 and j >= 0:\n        if word[i] in vowels:\n            return word[i]\n        elif word[j] in vowels:\n            return word[j]\n        else:\n            i -= 1\n        \n    return \"\"\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "get_closest_vowel"}
{"task_id": "HumanEval/119", "completion": "<think>\n\n</think>\n\n```python\ndef match_parens(lst):\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n    \n    first, second = lst[0], lst[1]\n    result = is_balanced(first + second) or is_balanced(second + first)\n    return 'Yes' if result else 'No'\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n", "entry_point": "match_parens"}
{"task_id": "HumanEval/120", "completion": "<think>\n\n</think>\n\n```python\ndef maximum(arr, k):\n    if k <= 0:\n        return []\n    # Sort the array to find the top k elements\n    sorted_arr = sorted(arr)\n    # Return the last k elements of the sorted array\n    return sorted_arr[-k:]\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n", "entry_point": "maximum"}
{"task_id": "HumanEval/121", "completion": "<think>\n\n</think>\n\n```python\ndef solution(lst):\n    sum_odds = 0\n    for i, num in enumerate(lst):\n        if num % 2 != 0 and i % 2 == 0:\n            sum_odds += num\n    return sum_odds\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n", "entry_point": "solution"}
{"task_id": "HumanEval/122", "completion": "<think>\n\n</think>\n\n```python\ndef add_elements(arr, k):\n    total = 0\n    for i in range(k):\n        num = arr[i]\n        if len(str(num)) <= 2:\n            total += num\n    return total\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "add_elements"}
{"task_id": "HumanEval/123", "completion": "<think>\n\n</think>\n\n```python\ndef get_odd_collatz(n):\n    result = []\n    current = n\n    while current != 1:\n        if current % 2 == 1:\n            result.append(current)\n        else:\n            current //= 2\n        result.append(current)\n    return sorted(result)\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "get_odd_collatz"}
{"task_id": "HumanEval/124", "completion": "<think>\n\n</think>\n\n```python\ndef valid_date(date):\n    \"\"\"You have to write a function which validates a given date string and returns True if the date is valid otherwise False.\"\"\"\n    # Check if the input is empty\n    if not date:\n        return False\n    \n    # Check month format (mm-dd-yyyy)\n    parts = date.split('-')\n    \n    # If the number of parts is incorrect, return False\n    if len(parts) != 4:\n        return False\n    \n    month, day, year = map(int, parts)\n    \n    # Validate month range (1-12)\n    if month < 1 or month > 12:\n        return False\n    \n    # Validate day range for each month\n    if (month in [4,6,9,11]) and (day < 1 or day > 30):\n        return False\n    \n     elif (month in [1,3,5,7,8]) and (day < 1 or day > 31):\n         return False\n    \n     elif (month == 2) and (day < 0 or day > year % 4 + year // 4 - year // year % ...): \n         pass\n        \n     else: \n         return True\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n", "entry_point": "valid_date"}
{"task_id": "HumanEval/125", "completion": "<think>\n\n</think>\n\n```python\ndef split_words(txt):\n    words = txt.split()\n    if not words:\n        return [chr(i) for i in range(97, 123)]\n    return words\n```", "test": "def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n", "entry_point": "split_words"}
{"task_id": "HumanEval/126", "completion": "<think>\n\n</think>\n\n```python\ndef is_sorted(lst):\n    return all(lst[i] <= lst[i + 1] for i in range(len(lst) - 1))\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n", "entry_point": "is_sorted"}
{"task_id": "HumanEval/127", "completion": "<think>\n\n</think>\n\n```python\ndef intersection(interval1, interval2):\n    # Find the overlap between the two intervals\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    \n    # Check if there is any overlap\n    if start <= end:\n        return \"YES\" if is_prime(end - start) else \"NO\"\n    else:\n        return \"NO\"\n    \ndef is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n", "entry_point": "intersection"}
{"task_id": "HumanEval/128", "completion": "<think>\n\n</think>\n\n```python\ndef prod_signs(arr):\n    if not arr:\n        return None\n    \n    product = 1\n    sign_product = 1\n    \n    for num in arr:\n        if num == 0:\n            sign_product *= 0\n            continue\n        \n        # Determine the sign of the number (1 or -1)\n        if num % 2 == 0:\n            sign_product *= -1\n        \n        product *= abs(num)\n    \n    return product * sign_product\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "prod_signs"}
{"task_id": "HumanEval/129", "completion": "<think>\n\n</think>\n\n```python\ndef minPath(grid, k):\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    # Use a priority queue to find the minimum path\n    import heapq\n    \n    # Create a list to keep track of the current path values and their indices\n    heap = []\n    \n    # Initialize the heap with each cell's value and its starting position (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            heapq.heappush(heap, (grid[i][j], i, j))\n    \n    # Keep track of visited cells to avoid revisiting them\n    visited = set()\n    \n    result = []\n    \n    while heap:\n        current_value, row_idx, col_idx = heapq.heappop(heap)\n        \n        if (row_idx + col_idx) not in visited:\n            result.append(current_value)\n            visited.add(row_idx + col_idx)\n            \n        if len(result) == k:\n            break\n        \n        # Try moving to all possible neighbors and add them to the heap if unvisited or have lower value\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                new_row = row_idx + dr\n                new_col = col_idx + dc\n                \n                if new_row >= 0 and new_row < rows and new_col >= 0 and new_col < cols:\n                    neighbor_value = grid[new_row][new_col]\n                    \n                    if neighbor_value <= current_value - k: \n                        heapq.heappush(heap, (neighbor_value - k * abs(dr), new_row + dc * k % rows // abs(dr), \n                                            abs(new_col) % cols))\n```\n\nThis solution uses a priority queue approach with Dijkstra-like logic. The key idea is that we always select the smallest possible next step based on values. This ensures that we find a unique minimum path efficiently.", "test": "def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n", "entry_point": "minPath"}
{"task_id": "HumanEval/130", "completion": "<think>\n\n</think>\n\n```python\ndef tri(n):\n    \"\"\"Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = [1, 3, 2]\n    \"\"\"\n    \n    result = []\n    \n    if n == 0:\n        return [0]\n    \n        # Initialize with first few terms of the sequence\n        result.append(3)\n        \n        for i in range(2, n+1):\n            if i % 2 == 0:  \n                result.append(i / float(i))\n            else:\n                prev_prev_prev = result[i-3]  \n                prev_prev = result[i-2]  \n                prev_0_999999_888888_777777_666666_\n                \n                # Placeholder for actual calculation logic here (as per problem statement)\n                \n                # Corrected placeholder logic based on problem statement (as per example given)\n                \n                current_term_value = (\n                    result[i-4] +\n                    result[i-5] +\n                    prev_prev_prev +\n                    i / float(i))\n                \n            # Add current term to list after calculation\n                \n        return sorted(result)\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n", "entry_point": "tri"}
{"task_id": "HumanEval/131", "completion": "<think>\n\n</think>\n\n```python\ndef digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\"\"\"\n    product = 1\n    for digit in str(n):\n        digit = int(digit)\n        if digit % 2 != 0:\n            product *= digit\n        else:\n            continue\n    return product if all(d % 2 != 0 for d in str(n)) else 0\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n", "entry_point": "digits"}
{"task_id": "HumanEval/132", "completion": "<think>\n\n</think>\n\n```python\ndef is_nested(string):\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        else:\n            if stack and stack[-1] == '[':\n                stack.pop()\n            else:\n                return False\n    return True\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n", "entry_point": "is_nested"}
{"task_id": "HumanEval/133", "completion": "<think>\n\n</think>\n\n```python\ndef sum_squares(lst):\n    \"\"\"You are given a list of numbers.\n    You need to return the sum of squared numbers in the given list,\n    round each element in the list to the upper int(Ceiling) first.\n    \n    Examples:\n        For lst = [1,2,3] the output should be 14\n        For lst = [1,4,9] the output should be 98\n        For lst = [1,3,5,7] the output should be 84\n    \n    \"\"\"\n    # Round each element to ceiling (i.e., take integer part + 0.5)\n    rounded_list = [round(x + 0.5) for x in lst]\n    \n    # Sum of squares\n    return sum(x ** 2 for x in rounded_list)\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "sum_squares"}
{"task_id": "HumanEval/134", "completion": "<think>\n\n</think>\n\n```python\ndef check_if_last_char_is_a_letter(txt):\n    # Check if the string is empty\n    if not txt:\n        return False\n    \n    # Check if the last character is a letter and not part of a word\n    last_char = txt[-1]\n    \n    # Split the string into words separated by spaces\n    words = txt.split()\n    \n    # If there are words, check if the last word's first character is a letter and not part of a word (i.e., it's only one character)\n    return len(words) > 0 and (last_char.isalpha() and len(words[-1]) == 1)\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "check_if_last_char_is_a_letter"}
{"task_id": "HumanEval/135", "completion": "<think>\n\n</think>\n\n```python\ndef can_arrange(arr):\n    if not arr:\n        return -1\n    max_index = -1\n    for i in range(len(arr) - 1):\n        if arr[i] <= arr[i + 1]:\n            max_index = i + 1\n    return max_index if max_index != -1 else -1\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n", "entry_point": "can_arrange"}
{"task_id": "HumanEval/136", "completion": "<think>\n\n</think>\n\n```python\ndef largest_smallest_integers(lst):\n    a = None\n    b = None\n    \n    for num in lst:\n        if num < 0:\n            a = num\n        elif num > 0:\n            b = num\n    \n    return (a, b)\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n", "entry_point": "largest_smallest_integers"}
{"task_id": "HumanEval/137", "completion": "<think>\n\n</think>\n\n```python\ndef compare_one(a, b):\n    if isinstance(a, (int, float)) and isinstance(b, (int, float)):\n        return a if a > b else b\n    elif isinstance(a, (int, float)) or isinstance(b, (int, float)):\n        return a if a > b else b\n    elif isinstance(a) == str and isinstance(b) == str:\n        return a if a > b else b\n    elif isinstance(a) == str or isinstance(b) == str:\n        return None  # If they are equal as strings but not numbers", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "compare_one"}
{"task_id": "HumanEval/138", "completion": "<think>\n\n</think>\n\n```python\ndef is_equal_to_sum_even(n):\n    \"\"\"Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers.\"\"\"\n    return n >= 8 and n % 2 == 0\n```", "test": "def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n", "entry_point": "is_equal_to_sum_even"}
{"task_id": "HumanEval/139", "completion": "<think>\n\n</think>\n\n```python\ndef special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\"\"\"\n    \n    result = 1\n    for i in range(1, n + 1):\n        result *= i\n     return result\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n", "entry_point": "special_factorial"}
{"task_id": "HumanEval/140", "completion": "<think>\n\n</think>\n\n```python\ndef fix_spaces(text):\n    \"\"\"Given a string text, replace all spaces in it with underscores, and if a string has more than 2 consecutive spaces, then replace all consecutive spaces with -\"\"\"\n\n    # Replace multiple spaces with one underscore\n    text = ' '.join(text.split())\n    \n    # Replace two or more consecutive underscores with one hyphen\n    return '-' + ''.join([c for c in text if c != '-'])[1:]\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n", "entry_point": "fix_spaces"}
{"task_id": "HumanEval/141", "completion": "<think>\n\n</think>\n\n```python\ndef file_name_check(file_name):\n    \"\"\"Create a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n      the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    \n    Examples:\n        file_name_check(\"example.txt\") # => 'Yes'\n        file_name_check(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n    \n    Parameters:\n        *file_name*: String representing a filename\n    \n    Returns:\n        str: \"Yes\" or \"No\" based on validity\n    \n\"\"\"\n# Check for number of digits\nif len(file_name) > 3 or any(c.isdigit() for c in file_name):\n   return \"No\"\n\n# Check for exactly one dot\nif '.' not in file_name or len(file_name.split('.')) != 1:\n   return \"No\"\n\n# Check for valid part before dot (starts with letter)\nparts = [part.strip() for part in file_name.split('.')]\nif parts[0].isalpha() is False or len(parts[0]) == 0:\n   return \"No\"\n\n# Check after dot is allowed parts\nallowed_parts = ['txt', 'exe', 'dll']\nreturn \"Yes\"\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n", "entry_point": "file_name_check"}
{"task_id": "HumanEval/142", "completion": "<think>\n\n</think>\n\n```python\ndef sum_squares(lst):\n    \"\"\"\"\n    This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.\n    \n    Examples:\n    For lst = [1,2,3] the output should be 6\n    For lst = []  the output should be 0\n    For lst = [-1,-5,2,-1,-5]  the output should be -126\n    \n    \"\"\"\n    result = sum(x ** i for i, x in enumerate(lst) if i % (3 or (4 and not i % 3)) == 0)\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n", "entry_point": "sum_squares"}
{"task_id": "HumanEval/143", "completion": "<think>\n\n</think>\n\n```python\ndef words_in_sentence(sentence):\n    words = sentence.split()\n    result = []\n    for word in words:\n        if len(word) in [2, 3, 5, 7, 11, 13]:\n            result.append(word)\n    return \" \".join(result)\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n", "entry_point": "words_in_sentence"}
{"task_id": "HumanEval/144", "completion": "<think>\n\n</think>\n\n```python\ndef simplify(x, n):\n    # Convert fractions to integers for easier calculation\n    numerator_x, denominator_x = map(int, x.split('/'))\n    numerator_n, denominator_n = map(int, n.split('/'))\n\n    # Check if x * n is an integer\n    return (numerator_x * denominator_n) % (denominator_x * denominator_n) == 0\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n", "entry_point": "simplify"}
{"task_id": "HumanEval/145", "completion": "<think>\n\n</think>\n\n```python\ndef order_by_points(nums):\n    \"\"\"Sorts the list of integers based on the sum of their digits, then by index.\"\"\"\n    return sorted(nums, key=lambda x: (sum(int(d) for d in str(x)), nums.index(x)))\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "order_by_points"}
{"task_id": "HumanEval/146", "completion": "<think>\n\n</think>\n\n```python\ndef specialFilter(nums):\n    count = 0\n    for num in nums:\n        if num > 10 and (num % 2 != 0) and (num // 10 % 2 != 0) and (num % 10 % 2 != 0):\n            count +=1\n    return count\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n", "entry_point": "specialFilter"}
{"task_id": "HumanEval/147", "completion": "<think>\n\n</think>\n\n```python\ndef get_max_triples(n):\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] + a[j] % 3 == 0:\n                count += 1\n                break\n    return count\n```", "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n", "entry_point": "get_max_triples"}
{"task_id": "HumanEval/148", "completion": "<think>\n\n</think>\n\n```python\ndef bf(planet1, planet2):\n    \"\"\"\n    There are eight planets in our solar system: the closerst to the Sun is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, Uranus, Neptune.\n    \n    The function takes two planet names as strings and returns a tuple containing all planets whose orbits are located between the orbit of planet1 and the orbit of planet2.\n    \n    Parameters:\n        planet1 (str): The name of the first planet.\n        planet2 (str): The name of the second planet.\n    \n    Returns:\n        tuple: A tuple containing all planets whose orbits are between them. Sorted by proximity to Sun. Empty tuple if invalid input or no such planets exist.\n\n    Examples:\n        bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n        bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n        bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    \"\"\"\n    # Check if both inputs are valid planetary names\n    if not isinstance(planet1, str) or not isinstance(planet2, str):\n        return ()\n    \n    # Create a list of valid planetary names in order\n    valid_planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\",\n                     \"Jupiter\", \"Saturn\",\"Uranus\",\"Neptune\"]\n    \n    # Find indices where each input appears in 'valid_planets'\n     index_1 = valid_planets.index(planet1)\n     index_2 = valid_planets.index(planet2)\n     \n     # Use binary search to find positions\n     left = index_1 - 0.5 * (index_2 - index_1)\n     right = index_2 + 0.5 * (index_2 - index_1)\n     \n     result_indices = list(range(left + 0.5 * (right - left), right))\n     \n    \n      return tuple(valid_planets[i] for i in result_indices)  \n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n", "entry_point": "bf"}
{"task_id": "HumanEval/149", "completion": "<think>\n\n</think>\n\n```python\ndef sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\"\"\"\n    \n    # Filter out words with odd lengths\n    filtered = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort by length ascending, then alphabetically (default)\n    \n        filtered.sort()\n    \n        return filtered\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n", "entry_point": "sorted_list_sum"}
{"task_id": "HumanEval/150", "completion": "<think>\n\n</think>\n\n```python\ndef x_or_y(n, x, y):\n    if is_prime(n):\n        return x\n    else:\n        return y\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n", "entry_point": "x_or_y"}
{"task_id": "HumanEval/151", "completion": "<think>\n\n</think>\n\n```python\ndef double_the_difference(lst):\n    sum_squares = 0\n    for num in lst:\n        if isinstance(num, int) and num > 0:\n            sum_squares += num * num\n    return sum_squares\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n", "entry_point": "double_the_difference"}
{"task_id": "HumanEval/152", "completion": "<think>\n\n</think>\n\n```python\ndef compare(game, guess):\n    result = []\n    for g, s in zip(game, guess):\n        result.append(abs(g - s))\n    return result\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "compare"}
{"task_id": "HumanEval/153", "completion": "<think>\n\n</think>\n\n```python\ndef Strongest_Extension(class_name, extensions):\n    return f\"{class_name}.{extensions[0]}\"\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n", "entry_point": "Strongest_Extension"}
{"task_id": "HumanEval/154", "completion": "<think>\n\n</think>\n\n```python\ndef cycpattern_check(a, b):\n    return False\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n", "entry_point": "cycpattern_check"}
{"task_id": "HumanEval/155", "completion": "<think>\n\n</think>\n\n```python\ndef even_odd_count(num):\n    count_even = 0\n    count_odd = 0\n    for digit in str(num):\n        if int(digit) % 2 == 0:\n            count_even += 1\n        else:\n            count_odd += 1\n    return (count_even, count_odd)\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "even_odd_count"}
{"task_id": "HumanEval/156", "completion": "<think>\n\n</think>\n\n```python\ndef int_to_mini_roman(number):\n    roman_numerals = [\n        (1000, 'M'),\n        (90, 'CM'),\n        (50, 'L'),\n        (40, 'XL'),\n        (10, 'X'),\n        (9, 'IX'),\n        (5, 'V'),\n        (4, 'IV'),\n    ]\n    result = ''\n    for value, symbol in roman_numerals:\n        if number >= value:\n            result += symbol * number // value\n            number -= value * number // value\n    return result.lower()\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "int_to_mini_roman"}
{"task_id": "HumanEval/157", "completion": "<think>\n\n</think>\n\n```python\ndef right_angle_triangle(a, b, c):\n    return a**2 + b**2 == c**2 or a**2 + c**2 == b**2 or b**2 + c**2 == a**\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n", "entry_point": "right_angle_triangle"}
{"task_id": "HumanEval/158", "completion": "<think>\n\n</think>\n\n```python\ndef find_max(words):\n    \"\"\"Write a function that accepts a list of strings.\n    The list contains different words. Return the word with maximum number of unique characters. If multiple strings have maximum number of unique characters, return the one which comes first in lexicographical order.\n\n    find_max([\"name\", \"of\", \"string\"]) == \"string\"\n    find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n    find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\"\n    \"\"\"\n    max_count = 0\n    result = \"\"\n    \n    for word in words:\n        count = len(set(word))\n        if count > max_count:\n            max_count = count\n            result = word\n        elif count == max_count:\n            if word < result:\n                result = word\n    \n    return result\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n", "entry_point": "find_max"}
{"task_id": "HumanEval/159", "completion": "<think>\n\n</think>\n\n```python\ndef eat(number, need, remaining):\n    total_eaten = number + need\n    remaining_carrots = remaining - total_eaten if remaining >= total_eaten else 0\n    \n    return [total_eaten, remaining_carrots]\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n", "entry_point": "eat"}
{"task_id": "HumanEval/160", "completion": "<think>\n\n</think>\n\n```python\ndef do_algebra(operator, operand):\n    result = operand[0]\n    for i in range(1, len(operand)):\n        if operator[i] == '+':\n            result += operand[i]\n        elif operator[i] == '-':\n            result -= operand[i]\n        elif operator[i] == '*':\n            result *= operand[i]\n        elif operator[i] == '//':\n            result = operand[0] // operand[1]\n        elif operator[i] == '**':\n            result = operand[0]**operand[1]\n    return result\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['//', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "do_algebra"}
{"task_id": "HumanEval/161", "completion": "<think>\n\n</think>\n\n```python\ndef solve(s):\n    result = []\n    for char in s:\n        if char.isalpha():\n            if char.islower():\n                result.append(char.upper())\n            else:\n                result.append(char.lower())\n        else:\n            result.append(char)\n    return ''.join(result)\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n", "entry_point": "solve"}
{"task_id": "HumanEval/162", "completion": "<think>\n\n</think>\n\n```python\ndef string_to_md5(text):\n    if not text:\n        return None\n    return hashlib.md5(text.encode()).hexdigest()\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "string_to_md5"}
{"task_id": "HumanEval/163", "completion": "<think>\n\n</think>\n\n```python\ndef generate_integers(a, b):\n    result = []\n    for num in range(a, b + 1):\n        if num % 2 == 0:\n            result.append(num)\n    return result\n```", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "generate_integers"}
